unit ssl_tsl;

uses dspic_additional_string_library,lib_Delays_LIO,def_io,lib1_enc600_V3_5_b,
     enc_lib_user,lib2_enc600_V3_5_b,df_lib_SPI1,crc16_lib,
     Tftp_Server,config,HTTP_Send;

procedure SSL_Init;
procedure HTTPProcDataIn_SSL(len_ : word; j : byte);
function OpenTCPConnection_SSL(port : word) : boolean;
function SendTCP_SSL(len : word) : boolean;
function SendTCPwait_SSL(len : word) : boolean;
function Open_SSL(port : word) : boolean;

implementation

procedure out_broadcast_local(port,len : word; var d_in : array[4096] of char);
var broadcast_ip : array[4] of byte;
var i,j : word;
    buf : string[1300];
begin
  broadcast_ip[0] := 255;
  broadcast_ip[1] := 255;
  broadcast_ip[2] := 255;
  broadcast_ip[3] := 255;

  j := 0;
  while len <> 0 do
    begin
      i := len;
      if i > 1280 then i := 1280;

      Mem_Cpy(@buf,@d_in[j],i);

      Send_UDP_Broadcast(broadcast_ip,port,port,i,buf);
      Do_EthernetProc;

      j := j + i;
      len := len - i;
    end;
end;

procedure SSL_Init;
begin
  HTTP_send_Port_ssl := TMR1 + 23456;
  certificate_len := 0;
  host_response_len_ssl := 0;
end;

procedure HTTPProcDataIn_SSL(len_ : word; j : byte);
var max_len : word;
label next_;
begin
  Socket[j].Keep_Alive := true;

  if host_response_len_ssl >= 4096 then exit;

  if host_response_len_ssl <> 0 then    // one packet arrived
    begin
      max_len := 4096 - host_response_len_ssl;
      if len_ > max_len then len_ := max_len;
    end;

  CopyEthMem_CPToRam(@host_response[host_response_len_ssl], len_);
  host_response_len_ssl := host_response_len_ssl + len_;
end;

function OpenTCPConnection_SSL(port : word) : boolean;
var i : word;
label end_end_,again_;
begin
  i := 0;

again_:

  Wait_With_Eth(100);

  result := false;

  if Str_Len(server_address_url) < 3 then exit;

  if IsIP(server_address_url) <> 0 then
    begin
      Str2IP(server_address_url,server_addr);
    end
  else
  if Dns_Resolve(server_address_url,server_addr) = false then
  if Dns_Resolve(server_address_url,server_addr) = false then
    begin
      if UDP_debug <> 0 then
        begin
          Socket_TCP_buf := 'DNS fail';
          out_broadcast_local(33335,Str_Len(Socket_TCP_buf),Socket_TCP_buf);
        end;
      goto end_end_;
    end;

  o_sock_ssl := 11;

  Close_TCP_Connection_Advance(o_sock_ssl);   // we use tcp socket 11

  TCP_Close_Port(HTTP_send_Port_ssl);

  HTTP_send_Port_ssl := HTTP_send_Port_ssl + 1;

  if HTTP_send_Port_ssl > 65000 then HTTP_send_Port_ssl := TMR1 + 23456;

  TCP_Open_Port(HTTP_send_Port_ssl);

  if Open_TCP_Connection_Advance(server_addr,port,HTTP_send_Port_ssl,o_sock_ssl) <> 0 then
    begin
      result := true;
      exit;
    end;

end_end_:
  if i < 2 then
    begin
      inc(i);
      goto again_; // try one more time
    end;
end;

function SendTCP_SSL(len : word) : boolean;
begin

  Wait_With_Eth(100);

  result := false;

  if Socket[o_sock_ssl].State_S <> 2 then exit;

      if UDP_debug <> 0 then
        begin
          out_broadcast_local(33335,len,HTTP_data_out);
        end;

      Socket[o_sock_ssl].RAM_ROM := 0;
      Socket[o_sock_ssl].Keep_Alive := true;
      Socket[o_sock_ssl].Exp_Time_Val := 100;
      Socket[o_sock_ssl].Do_Not_Fragment := 1;
      Socket[o_sock_ssl].Start_addr := @HTTP_data_out;
      Socket[o_sock_ssl].Stop_addr := Socket[o_sock_ssl].Start_addr + len;

      CC0_TCP := 0;
      while Socket[o_sock_ssl].State_S = 2 do      // while connected
        begin
          if CC0_TCP > 49 then break; // fail in 4 sec
          if Socket[o_sock_ssl].Start_addr = Socket[o_sock_ssl].Stop_addr then
            begin
              result := true;
              exit;
            end;
          Do_EthernetProc;
          Process_DHCP;
        end;
end;

function SendTCPwait_SSL(len : word) : boolean;
begin

  Wait_With_Eth(100);

  result := false;

  if Socket[o_sock_ssl].State_S <> 2 then exit;

      if UDP_debug <> 0 then
        begin
          out_broadcast_local(33335,len,HTTP_data_out);
        end;

      Socket[o_sock_ssl].RAM_ROM := 0;
      Socket[o_sock_ssl].Keep_Alive := true;
      Socket[o_sock_ssl].Exp_Time_Val := 100;
      Socket[o_sock_ssl].Do_Not_Fragment := 1;
      Socket[o_sock_ssl].Start_addr := @HTTP_data_out;
      Socket[o_sock_ssl].Stop_addr := Socket[o_sock_ssl].Start_addr + len;

      host_response_len_ssl := 0;

      CC0_TCP := 0;
      while Socket[o_sock_ssl].State_S = 2 do      // while connected
        begin
          if CC0_TCP > 49 then break; // fail in 4 sec
          if host_response_len_ssl <> 0 then
            begin
              result := true;
              break;
            end;
          Do_EthernetProc;
          Process_DHCP;
        end;
end;

function Open_SSL(port : word) : boolean;
var gen_i : byte;
begin
  result := false;
  certificate_len := 0;
  if OpenTCPConnection_SSL(port) <> 0 then
    begin
      Mem_Set(@HTTP_data_out,0,256);
      HTTP_data_out[0] := $16;
      HTTP_data_out[1] := $03;  // TLS Version 1.1
      HTTP_data_out[2] := $02;  // TLS Version 1.1
      HTTP_data_out[4] := $2f;  // TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite
      HTTP_data_out[5] := $01;  // client hello
      HTTP_data_out[8] := $2b;
      HTTP_data_out[9] := $03;
      HTTP_data_out[10] := $02;
	  // 32 random bytes
      for gen_i := 11 to 42 do 
	    HTTP_data_out[gen_i] := Hi(Table16[Lo(TMR1+gen_i)]); // generate random
	   
	  // ciphersuite list 
      HTTP_data_out[45] := $04;
      HTTP_data_out[47] := $2f;
      HTTP_data_out[49] := $ff;
      HTTP_data_out[50] := $01;
      if SendTCPwait_SSL(52) <> 0 then
        begin
          Wait_With_Eth(500);
          if UDP_debug <> 0 then
            begin
              out_broadcast_local(33335,host_response_len_ssl,host_response);
            end;
          Mem_Cpy(@certificate,@host_response,host_response_len_ssl);
          certificate_len := host_response_len_ssl;
        end;
      result := true;
    end;
end;

end.