unit unSSL_TLS;

uses dspic_additional_string_library,lib_Delays_LIO,def_io,lib1_enc600_V3_5_b,
     enc_lib_user,lib2_enc600_V3_5_b,df_lib_SPI1,crc16_lib,
     Tftp_Server,config,HTTP_Send,definitions_ENC600,unX509Certificate;

procedure Random_Init;
procedure Random_Array_32(d_in : ^byte);
procedure Random_Array_46(d_in : ^byte);
procedure MD5SHA(dataIn : ^char; dataLength : word; shaMd5
                   , restoreContextID // 0 - none
                                      // 1 - SHA 1
                                      // 2 - MD5
                   , saveContextID    // 0 - none
                                      // 1 - SHA 1
                                      // 2 - MD5
                   : byte);
procedure MD5SHAFinal(dataIn, dataOut : ^char; dataLength : word; shaMd5, contextID: byte);
procedure HMAC_ShaMd5(secretKey : ^byte; secretKeyLength : word; textToHash : ^byte;
                      textLength : word; hmacResult : ^byte; shaMd5 : byte);
procedure AES_128_CBC_encrypt(key16, iv16, text : ^char; text_len : word);
procedure AES_128_CBC_decrypt(key16, iv16, text : ^char; text_len : word);
function  modexp(var y : array[128] of byte;
                 var e : array[128] of byte; e_len : word;
                 var x : array[128] of byte; x_len : word;
                 var m : array[128] of byte; m_len : word): byte;
procedure SSL_Init;
procedure HTTPProcDataIn_SSL(len_ : word; j : byte);
function OpenTCPConnection_SSL(port : word) : boolean;
function Open_SSL(port : word) : boolean;
procedure PRF(secretKey: ^byte; secretKeyLength: word;
              aLabel: ^byte; labelLength: word;
              seed: ^byte; seedLength: word;
              prfOut: ^byte; prfLength: word);
              
procedure AddToHash(hashByte: byte; ShaMD5: byte);

type TtoHash = record
  hashed: boolean;           // indicates if dataIn is hashed
  firstBlock: boolean;       // if set, then hash engine is reset
  dataLength: byte;          // current length of dataIn
  dataIn: array[65] of byte; // data to be hashed, 65 because we will always transfer one byte to the next iteration
end;

var toHashMD5, toHashSHA1: TtoHash;

implementation



const HASHLST = 12;   // ECON1
      HASHOP  = 13;   // ECON1
      HASHEN  = 14;   // ECON1
      SHA1MD5 = 12;   // ECON2
      HASHIF  = 13;   // EIR
      
// handshake type
const TLS_HANDSHAKE_HELLO_REQUEST       =  0x00; //  0
      TLS_HANDSHAKE_CLIENT_HELLO        =  0x01; //  1
      TLS_HANDSHAKE_SERVER_HELLO        =  0x02; //  2
      TLS_HANDSHAKE_CERTIFICATE         =  0x0B; // 11
      TLS_HANDSHAKE_SERVER_KEY_EXCHANGE =  0x0C; // 12
      TLS_HANDSHAKE_CERTIFICATE_REQUEST =  0x0D; // 13
      TLS_HANDSHAKE_SERVER_HELLO_DONE   =  0x0E; // 14
      TLS_HANDSHAKE_CERTIFICATE_VERIFY  =  0x0F; // 15
      TLS_HANDSHAKE_CLIENT_KEY_EXCHANGE =  0x10; // 16
      TLS_HANDSHAKE_FINISHED            =  0x14; // 20

// content type
const TLS_CONTENT_CHANGE_CIPHER         =  0x14;
      TLS_CONTENT_ALERT                 =  0x15;
      TLS_CONTENT_HANDSHAKE             =  0x16;
      TLS_CONTENT_APPLICATION_DATA      =  0x17;

const TLS_VERSION_HIGH        = 0X03;  // TLS 1.1
      TLS_VERSION_LO          = 0X02;
      
type TPreMasterSecret = record
  clientVersion: array[2] of byte;
  random: array[46] of byte;
end;

var m_z,m_w,m_r : dword;
var MD5_buff, SHA1_buff : array[28] of byte;

var ServerCertificate: TX509Certificate;
var MD5Hash: array[16] of char;
var SHA1Hash: array[20] of char;
var masterSecret: array[48] of byte;
var preMasterSecret: TPreMasterSecret;

var client_write_MAC_secret : array[0..19] of byte;
var server_write_MAC_secret : array[0..19] of byte;
var client_write_key        : array[0..15] of byte;
var server_write_key        : array[0..15] of byte;
var client_write_IV         : array[0..15] of byte;
var server_write_IV         : array[0..15] of byte;

var serverRandom: array[32] of byte;
var clientRandom: array[32] of byte;

var serverCipherSuite: array[2] of byte;
var serverCompressionMethod: byte;

var serverCertificateStartIndex: word;
    // todo: session id goes to record parameters
    sessionIDLength: byte;
    helloDoneStartIndex: word;


procedure Random_Init;
begin
  LoWord(m_z) := TMR1;
  HiWord(m_z) := TMR1+127;
  LoWord(m_w) := TMR1+369;
  HiWord(m_w) := TMR1+768;
end;

function Random : dword;
begin
  m_z := 36969 * (m_z and 65535) + (m_z shr 16);
  m_w := 18000 * (m_w and 65535) + (m_w shr 16);
  result := (m_z shl 16) + m_w;
end;

procedure AnalyzeRandom;
begin
  m_r := Random;
  while ((Lo(m_r) = 0) or (Hi(m_r) = 0) or (Higher(m_r) = 0) or (Highest(m_r) = 0)) do m_r := Random;
end;

// number of bytes must be divisible by 4
procedure Random_Array(randomData : ^byte; numberOfBytes: byte);
var i : word;
begin
  numberOfBytes := numberOfBytes div 4;
  i := 0;
  while i < numberOfBytes do
    begin
      AnalyzeRandom;
      randomData^ := Lo(m_r);
      inc(randomData);
      randomData^ := Hi(m_r);
      inc(randomData);
      randomData^ := Higher(m_r);
      inc(randomData);
      randomData^ := Highest(m_r);
      inc(randomData);
      inc(i);
    end;
end;

procedure Random_Array_32(d_in : ^byte);
var i : word;
begin
  i := 0;
  while i < 8 do
    begin
      AnalyzeRandom;
      d_in^ := Lo(m_r);
      inc(d_in);
      d_in^ := Hi(m_r);
      inc(d_in);
      d_in^ := Higher(m_r);
      inc(d_in);
      d_in^ := Highest(m_r);
      inc(d_in);
      inc(i);
    end;
end;

procedure Random_Array_46(d_in : ^byte);
var i : byte;
begin
  i := 0;
  while i < 11 do
    begin
      AnalyzeRandom;
      d_in^ := Lo(m_r);
      inc(d_in);
      d_in^ := Hi(m_r);
      inc(d_in);
      d_in^ := Higher(m_r);
      inc(d_in);
      d_in^ := Highest(m_r);
      inc(d_in);
      inc(i);
    end;
  // two more bytes to make it 46
  AnalyzeRandom;
  d_in^ := Lo(m_r);
  inc(d_in);
  d_in^ := Hi(m_r);
end;

procedure dma_write(addr : word; d_in : ^char; len : word);
begin
  CopyRamToEthMem(d_in, $680, len);
  CopyEthMemToEthMem($680,addr,len);
end;

procedure dma_read(addr : word; d_out : ^char; len : word);
begin
  CopyEthMemToEthMem(addr,$680,len);
  CopyEthMemToRam($680,d_out,len);
end;

procedure MD5SHA(  dataIn : ^char;
                   dataLength : word; 
                   shaMd5             // 0 - SHA1, 1 - MD5
                   , restoreContextID // 0 - none
                                      // 1 - SHA 1
                                      // 2 - MD5
                   , saveContextID    // 0 - none
                                      // 1 - SHA 1
                                      // 2 - MD5
                   : byte);
var i : word;
    buf : word;
begin
  buf := Eth_ReadReg(ECON2_);
  if shaMd5 = 1 then
    begin
      buf.SHA1MD5 := 0;           // MD5
      shaMd5 := 16;
    end
  else
    begin
      buf.SHA1MD5 := 1;           // SHA1
      shaMd5 := 20;
    end;
  Eth_WriteReg(ECON2_, buf);
  
  buf := Eth_ReadReg(ECON1_);

  if restoreContextID = 2 then
    begin
      dma_write(0x7A40, @MD5_buff, 28);
      buf.HASHOP := 1; // continue prev hash
    end
  else if restoreContextID = 1 then
    begin
      dma_write(0x7A40, @SHA1_buff, 28);
      buf.HASHOP := 1; // continue prev hash
    end
  else
    begin
      buf.HASHOP := 0; // begin a new hash
    end;

  buf.HASHEN := 1;
  i := 0;
  if dataLength > 64 then
    begin
      buf.HASHLST := 0;           // HASHLST

      Eth_WriteReg(ECON1_, buf);
      while dataLength > 64 do
        begin
          buf := Eth_ReadReg(EIR_);
          buf.HASHIF := 0;           // HASHIF
          Eth_WriteReg(EIR_, buf);
          dma_write(0x7A00, dataIn + i, 64);
          while (Eth_ReadReg(EIR_) and $2000) = 0 do delayms(1); // HASHIF
          dataLength := dataLength - 64;
          i := i + 64;
        end;

      if saveContextID = 2 then
        begin
          dma_read(0x7A70, @MD5_buff, 28);
        end
      else if saveContextID = 1 then
        begin
          dma_read(0x7A70, @SHA1_buff, 28);
        end;
    end;

  buf := Eth_ReadReg(ECON1_);
  buf.HASHEN := 0;           // HASHEN
  Eth_WriteReg(ECON1_, buf);
end;

procedure MD5SHAFinal(dataIn, dataOut : ^char; dataLength : word; shaMd5, restoreContextID: byte);
var buf : word;
begin
  buf := Eth_ReadReg(ECON2_);
  if shaMD5 = 1 then // MD5
    begin
      shaMD5 := 16;
      buf.SHA1MD5 := 0;
    end
  else // SHA1
    begin
      shaMD5 := 20;
      buf.SHA1MD5 := 1;
    end;
  Eth_WriteReg(ECON2_, buf);
  
  buf := Eth_ReadReg(ECON1_);
  if restoreContextID = 2 then
    begin
      dma_write(0x7A40, @MD5_buff, 28);
      buf.HASHOP := 1; // continue prev hash
    end
  else if restoreContextID = 1 then
    begin
      dma_write(0x7A40, @SHA1_buff, 28);
      buf.HASHOP := 1; // continue prev hash
    end
  else
    begin
      buf.HASHOP := 0; // begin a new hash
    end;
  
  buf.HASHEN := 1;
  buf.HASHLST := 1;
  Eth_WriteReg(ECON1_, buf);
  
  buf := Eth_ReadReg(EIR_);
  buf.HASHIF := 0;
  Eth_WriteReg(EIR_, buf);
  
  if dataLength > 0 then  // must be <= 64
    begin
      dma_write(0x7A00, dataIn, dataLength);
      while (Eth_ReadReg(EIR_) and $2000) = 0 do // HASHIF
        delayms(1);
    end;
  dma_read(0x7A70, dataOut, shaMD5);
  buf := Eth_ReadReg(ECON1_);
  buf.HASHEN := 0;
  Eth_WriteReg(ECON1_, buf);
end;


//******************************************************************************
//
//
//
//******************************************************************************
procedure AddToHash(hashByte: byte; ShaMD5: byte);
var save, restore: byte;
    tmp: array[64] of byte;
    i: byte;
begin
  if ShaMD5 = 0 then
    begin
      toHashSHA1.hashed := false; // new data is pending
      toHashSHA1.dataIn[toHashSHA1.dataLength] := hashByte;
      toHashSHA1.dataLength := toHashSHA1.dataLength + 1;
      if (toHashSHA1.dataLength > 64) then  // do it only if another byte is pending after this block(because of the call to final)
        begin // hash the current block
          save := 1; // always save the context
          if toHashSHA1.firstBlock <> 0 then
            begin // we do not restore on the first block
              restore := 0;
            end
          else
            begin
              restore := 1;
            end;
          for i := 0 to 63 do
            tmp[i] := toHashSHA1.dataIn[i];
          MD5SHA(@tmp, // data to be hashed
                 65,                    // 64B actually, but the extra one will trigger a proper procedure
                 0,                     // SHA1
                 restore,               // context
                 save                   // context
                 );
          toHashSHA1.dataLength := 1; // one byte remained, move it to next iteration
          toHashSHA1.dataIn[0] := toHashSHA1.dataIn[64]; // this is the orphan that was not hashed
          toHashSHA1.hashed := true;    // not really needed?
          toHashSHA1.firstBlock := false;
        end;
    end
  else
    begin
      toHashMD5.hashed := false; // new data is pending
      toHashMD5.dataIn[toHashMD5.dataLength] := hashByte;
      toHashMD5.dataLength := toHashMD5.dataLength + 1;
      if (toHashMD5.dataLength > 64) then // do it only if another byte is pending after this block (because of the call to final)
        begin // hash the current block
          save := 2; // always save the context
          if toHashMD5.firstBlock <> 0 then
            begin // we do not restore on the first block
              restore := 0;
            end
          else
            begin
              restore := 2;
            end;
          for i := 0 to 63 do
            tmp[i] := toHashMD5.dataIn[i];
          MD5SHA(@tmp, // data to be hashed
                 65,                   // 64B actually, but the extra one will trigger a proper procedure
                 1,                    // MD5
                 restore,              // context
                 save);                // context

          toHashMD5.dataLength := 1; // one byte remained, move it to next iteration
          toHashMD5.dataIn[0] := toHashMD5.dataIn[64]; // this is the orphan that was not hashed
                                                       // move it to the next block
          toHashMD5.hashed := true;    // not really needed?
          toHashMD5.firstBlock := false;
        end;
    end;
end;

procedure HMAC_ShaMd5(secretKey : ^byte; secretKeyLength : word; textToHash : ^byte;
                      textLength : word; hmacResult : ^byte; shaMd5 : byte);
const BLOCK_SIZE = 64;
var ipad, opad : array[BLOCK_SIZE + 1] of char;
    i : word;
    isha: array [20] of byte;
    buf: array[BLOCK_SIZE] of byte;
    digestSize: byte;
    secretKeyHash: array[BLOCK_SIZE] of byte;
    saveContext, restoreContext: byte;
begin
  if shaMd5 = 0 then
    begin
      digestSize := 20;
      restoreContext := 1;
      saveContext := 1;
    end
  else
    begin
      digestSize := 16;
      restoreContext := 2;
      saveContext := 2;
    end;
    
  if secretKeyLength > BLOCK_SIZE then
    begin
        MD5SHA(secretKey, secretKeyLength, shaMd5, 0, saveContext);
        i := secretKeyLength div BLOCK_SIZE;
        i := i * BLOCK_SIZE;                     // completed bytes
        secretKeyLength := secretKeyLength mod BLOCK_SIZE; // remaining bytes

        MD5SHAFinal(secretKey + i, @secretKeyHash, secretKeyLength, shaMd5, restoreContext);
    end
  else
    begin
      for i := 0 to secretKeyLength - 1 do
        begin
          secretKeyHash[i] := secretKey^;
          inc(secretKey);
        end;
    end;

  //**** Inner Digest ****/
  Mem_Set(@ipad, 0x36, BLOCK_SIZE);
  Mem_Set(@opad, 0x5c, BLOCK_SIZE);
   
  for i := 0 to secretKeyLength - 1 do
     begin
       ipad[i] := ipad[i] xor secretKeyHash[i];
       opad[i] := opad[i] xor secretKeyHash[i];
     end;
  
  i := 0;
  MD5SHA(@ipad, BLOCK_SIZE + 1, shaMd5, 0, saveContext);
  if textLength > BLOCK_SIZE then
     begin
        MD5SHA(textToHash, textLength, shaMd5, restoreContext, saveContext);
        i := textLength div BLOCK_SIZE;
        i := i * BLOCK_SIZE;                     // completed bytes
        textLength := textLength mod BLOCK_SIZE; // remaining bytes
     end;
  MD5SHAFinal(textToHash + i, @isha, textLength, shaMd5, restoreContext);

  //**** Outter Digest ****
  MD5SHA(@opad, BLOCK_SIZE + 1, shaMd5, 0, restoreContext);
  MD5SHAFinal(@isha, hmacResult, digestSize, shaMd5, restoreContext);
end;

procedure AES_128_CBC_encrypt(key16, iv16, text : ^char; text_len : word);
var blocks,i,buf : word;
begin
  if (text_len mod 16) = 0 then 
    nop 
  else 
    exit;

  blocks := text_len div 16;

  while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for AES engine to be free...

  buf := Eth_ReadReg(ECON2_);
  buf.0 := 0;           // AESLEN 128-bit key
  buf.1 := 0;           // AESLEN 128-bit key
  Eth_WriteReg(ECON2_, buf);

  dma_write(0x7C00, key16, 16);

  buf := Eth_ReadReg(ECON1_);
  buf.11 := 1;           // AESST
  Eth_WriteReg(ECON1_, buf);
  while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for key to be loaded

  buf := Eth_ReadReg(ECON1_);
  buf.9 := 1;           // AESOP CBC encrypt
  buf.10 := 0;           // AESOP CBC encrypt
  Eth_WriteReg(ECON1_, buf);

  dma_write(0x7C20, iv16, 16);

  i := 0;
  while i < blocks do
    begin
      // write the next block ...
      dma_write(0x7C30, text + i*16, 16);
      buf := Eth_ReadReg(ECON1_);
      buf.11 := 1;           // AESST start encryption
      Eth_WriteReg(ECON1_, buf);
      while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for completion
      dma_read(0x7C20, text + i*16, 16);
      inc(i);
  end;
end;

procedure AES_128_CBC_decrypt(key16,iv16,text : ^char; text_len : word);
var blocks,i,buf : word;
begin
  if (text_len mod 16) = 0 then nop else exit;

  blocks := text_len div 16;

  while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for AES engine to be free...

  buf := Eth_ReadReg(ECON2_);
  buf.0 := 0;           // AESLEN 128-bit key
  buf.1 := 0;           // AESLEN 128-bit key
  Eth_WriteReg(ECON2_, buf);

  dma_write(0x7C00, key16, 16);

  buf := Eth_ReadReg(ECON1_);
  buf.11 := 1;           // AESST
  Eth_WriteReg(ECON1_, buf);
  while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for key to be loaded

  buf := Eth_ReadReg(ECON1_);
  buf.9 := 0;           // AESOP CBC decrypt
  buf.10 := 1;          // AESOP CBC decrypt
  Eth_WriteReg(ECON1_, buf);

  dma_write(0x7C30, iv16, 16);

  i := 0;
  while i < blocks do
    begin
      // write the next block ...
      dma_write(0x7C20, text + i*16, 16);
      buf := Eth_ReadReg(ECON1_);
      buf.11 := 1;           // AESST start decryption
      Eth_WriteReg(ECON1_, buf);
      while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for completion
      dma_read(0x7C40, text + i*16, 16);
      CopyEthMemToEthMem(0x7C40,0x7C30,16);
      inc(i);
    end;
end;

// Error codes:
// 0 - no error
// 1 - modulus not a power of 2
// 2 - exponent and key must be stricly less than m
// 3 - e and x must be strictly less than m
// 4 - For the Modular Exponentiation engine to work correctly, the
//      Most Significant (MSb) bit of M must be set."

function modexp (var y : array[128] of byte;
                 var e : array[128] of byte; e_len : word;
                 var x : array[128] of byte; x_len : word;
                 var m : array[128] of byte; m_len : word): byte;
var buf : array[128] of byte;
    buf1 : word;
begin
  result := 255; // failed
  // Only 512, 768, and 1024 bit moduli are supported
  if (m_len <> 64) and (m_len <> 96) and (m_len <> 128) then 
    begin
      result := 1;
      exit;
    end;

// e and x must be strictly less than m
{if (e_len > m_len) or (x_len > m_len) then
    begin
      result := 3;
      exit;
    end;}

{ datasheet 15.1
      "For the Modular Exponentiation engine to work correctly, the
      Most Significant (MSb) bit of M must be set."
}

  if (m[0] and 0x80) = 0 then
    begin
      result := 4;
      exit;
    end;

  // left-pad e, x with zeros
  Mem_Set(@buf, 0, m_len);
  Mem_Cpy(@buf + m_len - e_len, @e, e_len);
  dma_write(0x7800, @buf, m_len);

  Mem_Set(@buf, 0, m_len);
  Mem_Cpy(@buf + m_len - x_len, @x, x_len);
  dma_write(0x7880, @buf, m_len);

  dma_write(0x7900, @m, m_len);

  buf1 := Eth_ReadReg(ECON2_);
  buf1.2 := 0;                              // MODLEN 64
  buf1.3 := 0;                              // MODLEN 64
  if m_len = 96 then buf1.2 := 1            // MODLEN 96
  else if m_len = 128 then buf1.3 := 1;     // MODLEN 128
  Eth_WriteReg(ECON2_, buf1);

  buf1 := Eth_ReadReg(ECON1_);
  buf1.15 := 1;           // MODEXST enable modexp engine
  Eth_WriteReg(ECON1_, buf1);
  while (Eth_ReadReg(ECON1_) and $8000) <> 0 do delayms(1);

  dma_read(0x7880, @y, m_len);
  result := 0;// success
end;

procedure out_broadcast_local(port,len : word; var d_in : array[4096] of byte);
var broadcast_ip : array[4] of byte;
var i,j : word;
    buf : string[1300];
begin
  broadcast_ip[0] := 255;
  broadcast_ip[1] := 255;
  broadcast_ip[2] := 255;
  broadcast_ip[3] := 255;

  j := 0;
  while len <> 0 do
    begin
      i := len;
      if i > 1280 then i := 1280;

      Mem_Cpy(@buf,@d_in[j],i);

      Send_UDP_Broadcast(broadcast_ip,port,port,i,buf);
      Do_EthernetProc;

      j := j + i;
      len := len - i;
    end;
end;

procedure SSL_Init;
begin
  HTTP_send_Port_ssl := TMR1 + 23456;
  certificate_len := 0;
  host_response_len_ssl := 0;
end;

procedure HTTPProcDataIn_SSL(len_ : word; j : byte);
var max_len : word;
label next_;
begin
  Socket[j].Keep_Alive := true;

  if host_response_len_ssl >= 4096 then exit;

  if host_response_len_ssl <> 0 then    // one packet arrived
    begin
      max_len := 4096 - host_response_len_ssl;
      if len_ > max_len then len_ := max_len;
    end;

  CopyEthMem_CPToRam(@host_response[host_response_len_ssl], len_);
  host_response_len_ssl := host_response_len_ssl + len_;
end;

function OpenTCPConnection_SSL(port : word) : boolean;
var i : word;
label end_end_,again_;
begin
  i := 0;

again_:

  Wait_With_Eth(100);

  result := false;
  if Str_Len(server_address_url) < 3 then exit;

  if IsIP(server_address_url) <> 0 then
    begin
      Str2IP(server_address_url,server_addr);
    end
  else
    begin
      if Dns_Resolve(server_address_url,server_addr) = false then
        begin
          if Dns_Resolve(server_address_url,server_addr) = false then
            begin
              if UDP_debug <> 0 then
                begin
                  Socket_TCP_buf := 'DNS fail';
                  out_broadcast_local(33335,Str_Len(Socket_TCP_buf),Socket_TCP_buf);
                end;
              goto end_end_;
            end
          else
            begin
              if UDP_debug <> 0 then
                begin
                  Socket_TCP_buf := 'DNS resolved';
                  out_broadcast_local(33335, Str_Len(Socket_TCP_buf), Socket_TCP_buf);
                end;
            end;
        end
      else
        begin
          Socket_TCP_buf := 'DNS resolved';
          out_broadcast_local(33335, Str_Len(Socket_TCP_buf),Socket_TCP_buf);
          Mem_Cpy(@Socket_TCP_buf, @server_addr, 4);
          out_broadcast_local(33335, 4, Socket_TCP_buf);
        end;
    end;
  o_sock_ssl := 11;

  Close_TCP_Connection_Advance(o_sock_ssl);   // we use tcp socket 11

  TCP_Close_Port(HTTP_send_Port_ssl);

  HTTP_send_Port_ssl := HTTP_send_Port_ssl + 1;

  if HTTP_send_Port_ssl > 65000 then HTTP_send_Port_ssl := TMR1 + 23456;

  TCP_Open_Port(HTTP_send_Port_ssl);

  if Open_TCP_Connection_Advance(server_addr,port,HTTP_send_Port_ssl,o_sock_ssl) <> 0 then
    begin
      result := true;
      exit;
    end;

end_end_:
  if i < 2 then
    begin
      inc(i);
      goto again_; // try one more time
    end;
end;

function SendTCP_SSLobsolete(len : word) : boolean;
begin

  Wait_With_Eth(100);
  result := false;

  if Socket[o_sock_ssl].State_S <> 2 then exit;

      if UDP_debug <> 0 then
        begin
          out_broadcast_local(33335,len,HTTP_data_out);
        end;

      Socket[o_sock_ssl].RAM_ROM := 0;
      Socket[o_sock_ssl].Keep_Alive := true;
      Socket[o_sock_ssl].Exp_Time_Val := 100;
      Socket[o_sock_ssl].Do_Not_Fragment := 1;
      Socket[o_sock_ssl].Start_addr := @HTTP_data_out;
      Socket[o_sock_ssl].Stop_addr := Socket[o_sock_ssl].Start_addr + len;

      CC0_TCP := 0;
      while Socket[o_sock_ssl].State_S = 2 do      // while connected
        begin
          if CC0_TCP > 49 then break; // fail in 4 sec
          if Socket[o_sock_ssl].Start_addr = Socket[o_sock_ssl].Stop_addr then
            begin
              result := true;
              exit;
            end;
          Do_EthernetProc;
          Process_DHCP;
        end;
end;

function SendTCPwait_SSLobsolete(len : word) : boolean;
begin
  Wait_With_Eth(100);
  result := false;
  if Socket[o_sock_ssl].State_S <> 2 then exit;

      if UDP_debug <> 0 then
        begin
          out_broadcast_local(33335, len, HTTP_data_out);
        end;

      Socket[o_sock_ssl].RAM_ROM := 0;
      Socket[o_sock_ssl].Keep_Alive := true;
      Socket[o_sock_ssl].Exp_Time_Val := 100;
      Socket[o_sock_ssl].Do_Not_Fragment := 1;
      Socket[o_sock_ssl].Start_addr := @HTTP_data_out;
      Socket[o_sock_ssl].Stop_addr := Socket[o_sock_ssl].Start_addr + len;

      host_response := '';
      host_response_len_ssl := 0;

      CC0_TCP := 0;
      while Socket[o_sock_ssl].State_S = 2 do      // while connected
        begin
          if CC0_TCP > 49 then break; // fail in 4 sec
          if host_response_len_ssl <> 0 then
            begin
              result := true;
              break;
            end;
          Do_EthernetProc;
          Process_DHCP;
        end;
end;

// sends message from http_data_out
// encrypts if needed
function SendMessage(messageLength: word; waitForResponse: byte) : boolean;
var startAddress, stopAddress: word;
    msg: array[32] of char;
    i: byte;
begin
  Wait_With_Eth(100);
  result := false;
  // check if socket is connected
  if Socket[o_sock_ssl].State_S <> 2 then 
    begin
      if UDP_debug <> 0 then
          begin
            msg := 'Socket disconnected';
            out_broadcast_local(33335, 19, msg);
          end;
      exit;
    end;

      if UDP_debug <> 0 then
        begin
          out_broadcast_local(33335, messageLength, HTTP_data_out);
        end;
      
      // hash outgoing handshake messages, without headers
      if HTTP_data_out[0] = TLS_CONTENT_HANDSHAKE then
        begin
          for i := 5 to messageLength - 1 do
            begin
              AddToHash(HTTP_data_out[i], 0); // SHA-1
              AddToHash(HTTP_data_out[i], 1); // MD5
              //uart3_write(HTTP_data_out[i]);
            end;
        end;
        
      startAddress := @HTTP_data_out;
      stopAddress  := startAddress + messageLength;

      Socket[o_sock_ssl].RAM_ROM         :=    0;
      Socket[o_sock_ssl].Keep_Alive      := true;
      Socket[o_sock_ssl].Exp_Time_Val    := 100;
      Socket[o_sock_ssl].Do_Not_Fragment :=    1;
      Socket[o_sock_ssl].Start_addr      := startAddress;
      Socket[o_sock_ssl].Stop_addr       := stopAddress;

      host_response := '';
      host_response_len_ssl := 0;
      
      CC0_TCP := 0;
      while Socket[o_sock_ssl].State_S = 2 do      // while connected
        begin
          if CC0_TCP > 49 then 
            begin
              if UDP_debug <> 0 then
                begin
                  msg := 'Timeout on send';
                  out_broadcast_local(33335, 15, msg);
                end;

              break; // fail in 4 sec
            end;

          if waitForResponse <> 0 then
            begin
              if host_response_len_ssl <> 0 then
                begin
                  result := true;
                  break;
                end;
            end
          else
            begin
              if Socket[o_sock_ssl].Stop_addr = stopAddress then
                begin
                  result := true;
                  exit;
                end;
            end;
          Do_EthernetProc;
          Process_DHCP;
        end;
end;

// message should be prepared in HTTP_Data_Out
//  starting from startIndex with the length of messageLength
function SendHandshakeMessage(messageType: byte; startIndex, messageLength: word; waitForResponse: byte) : boolean;
var startAddress, stopAddress: word;
begin
  Wait_With_Eth(100);

  result := false;

  if Socket[o_sock_ssl].State_S <> 2 then exit;

      if UDP_debug <> 0 then
        begin
          out_broadcast_local(33335, messageLength, HTTP_data_out);
        end;
      startAddress := startIndex;
      startAddress := startAddress + @HTTP_data_out;
      stopAddress  := startAddress + messageLength;
      if startIndex = 0 then // header already prepared
        begin
        end
      else   //build header
        begin
          HTTP_data_out[0] := TLS_CONTENT_HANDSHAKE; // handshake type
          HTTP_data_out[1] := TLS_VERSION_HIGH;
          HTTP_data_out[2] := TLS_VERSION_LO;
          HTTP_data_out[3] := Hi(messageLength);
          HTTP_data_out[4] := Lo(messageLength);

          stopAddress  := stopAddress + 5; // 5 - handshake header length
        end;

      Socket[o_sock_ssl].RAM_ROM         :=    0;
      Socket[o_sock_ssl].Keep_Alive      := true;
      Socket[o_sock_ssl].Exp_Time_Val    :=  100;
      Socket[o_sock_ssl].Do_Not_Fragment :=    1;
      Socket[o_sock_ssl].Start_addr      := startAddress;
      Socket[o_sock_ssl].Stop_addr       := stopAddress;

      host_response := '';
      host_response_len_ssl := 0;

      CC0_TCP := 0;
      while Socket[o_sock_ssl].State_S = 2 do      // while connected
        begin
          if CC0_TCP > 49 then break; // fail in 4 sec
          
          if waitForResponse <> 0 then
            begin
              if host_response_len_ssl <> 0 then
                begin
                  result := true;
                  break;
                end;
            end
          else
            begin
              if Socket[o_sock_ssl].Start_addr = stopAddress then
                begin
                  result := true;
                  exit;
                end;
            end;
          Do_EthernetProc;
          Process_DHCP;
        end;
end;

// x = 128 bytes
function CreateClientKeyExchange: word; // returns number of bytes
var rsaCipherText: array[128] of byte; // 1024 bits
    i: byte;
    p: ^byte;
    msg: string[32];
begin
      // choose pre master secret
      Random_Array_46(@preMasterSecret.random);
      
      if UDP_debug then
        begin
          msg := 'preMasterSecret random';
          out_broadcast_local(33335, Str_Len(msg), msg);
          out_broadcast_local(33335,
                              46,
                              preMasterSecret.random);
        end;
      
      // set the TLS version
      preMasterSecret.clientVersion[0] := TLS_VERSION_HIGH;
      preMasterSecret.clientVersion[1] := TLS_VERSION_LO;
      
      // encrypt the premaster secret
      //  1. extend the pre master secret to 1024 bit (128 bytes) integer by adding Random
      //  2. use HTTP_data_out as a temporary storage
      //  3. form the 512 bit integer (64 bytes) as 00 02 <PS> 00 <Pre Master Secret>
      Random_Array(@HTTP_data_out, 248);
      HTTP_data_out[0]  := $00;  //
      HTTP_data_out[1]  := $02;  // padding identifier, ignore all bytes up to the first 0x00
      HTTP_data_out[79] := 0x00;
      HTTP_data_out[80] := TLS_VERSION_HIGH; // version hi
      HTTP_data_out[81] := TLS_VERSION_LO; // version lo
      for i := 0 to 45 do
        begin
           HTTP_data_out[82 + i] := preMasterSecret.random[i];
        end;
      
      if UDP_debug <> 0 then
          begin
            msg := 'public key: exp/base';
            out_broadcast_local(33335, Str_Len(msg), msg);
            msg[0] := Hi(ServerCertificate.PublicKey.Key.ExponentLength);
            msg[1] := Lo(ServerCertificate.PublicKey.Key.ExponentLength);
            out_broadcast_local(33335, 2, msg);
            
            msg[0] := Hi(ServerCertificate.PublicKey.Key.ModulusLength);
            msg[1] := Lo(ServerCertificate.PublicKey.Key.ModulusLength);
            out_broadcast_local(33335, 2, msg);
          end;
      
      // RSA encrypt PreMaster Secret
      i := modexp(rsaCipherText, // Y
             ServerCertificate.PublicKey.Key.Exponent, // E
             ServerCertificate.PublicKey.Key.ExponentLength,
             HTTP_data_out,  // pre master secret   // X or base B
             128,             // PreMasterSecret length with padding
             ServerCertificate.PublicKey.Key.Modulus, // M
             ServerCertificate.PublicKey.Key.ModulusLength
             );
             
      if  i <> 0 then
        begin
           msg := 'modexp failed N'; /// N = error code
           msg[14] := i;
           out_broadcast_local(33335, Str_Len(msg), msg);
           result := 0;
           exit;
        end;

      // build a "Client Key Exchange" message
      Mem_Set(@HTTP_data_out, 0, 256);

      // 1. TLS record header
      HTTP_data_out[0] := TLS_CONTENT_HANDSHAKE; // handshake type
      HTTP_data_out[1] := TLS_VERSION_HIGH;
      HTTP_data_out[2] := TLS_VERSION_LO;
      HTTP_data_out[3] := 0x00;
      HTTP_data_out[4] := 0x86;

      HTTP_data_out[5]  := TLS_HANDSHAKE_CLIENT_KEY_EXCHANGE;     // ClientKeyExchange message type, 0x10
      HTTP_data_out[6]  := $00;     // Message length Higher
      HTTP_data_out[7]  := $00;     // Message length Hi
      HTTP_data_out[8]  := $82;     // Message length Lo - 66 bytes
      
      HTTP_data_out[9]  := $00;
      HTTP_data_out[10] := $80;
      
      // copy rsaCipherText back to HTTP_data_out
       for i := 0 to 127 do
         begin
           HTTP_data_out[11 + i] := rsaCipherText[i];
         end;
      
      result := 139;
end;

function CreateClientHello: word; // returns number of bytes
var i: byte;
begin
      // build a "Client Hello" message
      Mem_Set(@HTTP_data_out, 0, 256);

      // 1. TLS record header
      HTTP_data_out[0] := TLS_CONTENT_HANDSHAKE; // handshake type
      HTTP_data_out[1] := TLS_VERSION_HIGH;
      HTTP_data_out[2] := TLS_VERSION_LO;
      HTTP_data_out[3]  := $00;     // content length HiByte
      HTTP_data_out[4]  := $2f;     // content length LoByte => 47B in total after this point

      // 2. Handshake header, hashing starts here
      HTTP_data_out[5]  := TLS_HANDSHAKE_CLIENT_HELLO;     // handshake type code = 1 => clienthello
      HTTP_data_out[6]  := $00;     // length
      HTTP_data_out[7]  := $00;     // length
      HTTP_data_out[8]  := $2b;     // length = 43 bytes from this point onwards

      // 3. client hello starts here
      HTTP_data_out[9]  := TLS_VERSION_HIGH;      // protocol version
      HTTP_data_out[10] := TLS_VERSION_LO;      // protocol version, TLS 1.1

      // client Random
      Random_Array_32(@clientRandom);
      for i := 0 to 31 do
        HTTP_data_out[i + 11] := clientRandom[i]; // from 11 to 42, inclusive

      HTTP_data_out[43] := $00;     // session id byte length, 0 bytes for client hello (no session yet)

      HTTP_data_out[44] := $00;     // ciphersuite list length, hiByte
      HTTP_data_out[45] := $04;     // ciphersuite list length, loByte = 4, i.e. 2 suites

      HTTP_data_out[46] := $00;     // ciphersuite list, suite 1
      HTTP_data_out[47] := $2f;     // ciphersuite list, single ciphersuite TLS_RSA_WITH_AES_128_CBC_SHA

      HTTP_data_out[48] := $00;     // no regotiation supported , suite 2
      HTTP_data_out[49] := $ff;     // no regotiation supported

      HTTP_data_out[50] := $01;     // compression list, compressionmethod 1
      HTTP_data_out[51] := $00;     // compression list, 'null' (no-op) compression
      
      result := 52;
end;

function CreateChangeCipher: word; // returns number of bytes
begin
      // build a "Change Cipher" message
      Mem_Set(@HTTP_data_out, 0, 256);

      // 1. TLS record header
      HTTP_data_out[0]  := TLS_CONTENT_CHANGE_CIPHER;     // content type = change cipher
      HTTP_data_out[1]  := TLS_VERSION_HIGH;
      HTTP_data_out[2]  := TLS_VERSION_LO;

      HTTP_data_out[3]  := $00;     // Message length Hi
      HTTP_data_out[4]  := $01;     // Record length Lo - 1 byte only

      HTTP_data_out[5]  := $01;     // ChangeCipherSpec
      result := 6;
end;

procedure CalculateMasterSecret(var masterSecretOut: array[48] of byte);
var aLabel : string[13];
    seed: array[64] of byte;
    i: byte;
begin
  aLabel := 'master secret';

  // seed = ClientHello.random + ServerHello.random
  for i := 0 to 31 do
    seed[i] := clientRandom[i];

  for i := 0 to 31 do
    seed[i + 32] := serverRandom[i];
  //uart3_write_text(' PRF MS ');
  PRF(@preMasterSecret,
      48,               // pre master key length
      @aLabel,          // label
      13,               // label length
      @seed,            // ClientHello.random + ServerHello.random
      64,               // seed length
      @masterSecret, // @masterSecretOut, // out masterSecret
      48);              // masterSecret length
end;

procedure CalculateKeys(var masterSecretIn: array[48] of byte);
var aLabel : string[13];
    seed: array[64] of byte;
    i: byte;
    keys: array[128] of byte;
begin
  aLabel := 'key expansion';

  // note that server and client Random are in this order now
  // seed = ServerHello.random + ClientHello.random
  for i := 0 to 31 do
    seed[i] := serverRandom[i];
  for i := 0 to 31 do
    seed[i+32] := clientRandom[i];

  uart3_write_text(' PRF ke ');
  PRF(@masterSecret, //In,  // note: master secret here
      48,               // master secret length
      @aLabel,          // label
      13,               // label length
      @seed,            // ServerHello.random + ClientHello.random
      64,               // seed length
      @keys,            // out keys
      104);             // PRF length , 20 + 20 + 16 + 16 + 16 + 16 = 104
      
  for i := 0 to 19 do
    client_write_MAC_secret[i] := keys[i];
  for i := 20 to 39 do
    server_write_MAC_secret[i-20] := keys[i];
  for i := 40 to 55 do
    client_write_key[i-40] := keys[i];
  for i := 56 to 71 do
    server_write_key[i-56] := keys[i];
  for i := 72 to 87 do
    client_write_IV[i-72]  := keys[i];
  for i := 88 to 103 do
    server_write_IV[i-88]  := keys[i];
end;

procedure CalculateVerifyData(var verifyDataOut: array[12] of byte);
var seed: array[36] of byte;   //md5 (16 bytes) + sha-1 (20 bytes)
    i: byte;
    aLabel: string[15];
begin
      aLabel := 'client finished';
      // copy MD5
      for i := 0 to 15 do
        begin
          seed[i] := MD5Hash[i];
        end;
      // copy SHA-1
      for i := 0 to 19 do
        begin
          seed[i + 16] := SHA1Hash[i];
        end;

     uart3_write_text(' PRF CF ');
     // compute verify data
     Prf(@MasterSecret,
         48,             // Master Secret Length
         @aLabel,        // label
         15,             // label length
         @seed,          // seed
         36,             // seed length
         @verifyDataOut, // verify_data
         12);            // verify_data length, must be at least 16, but we will take only 12
end;

function CreateClientFinished(): word; // returns number of bytes
var i: byte;
    verifyData: array[12] of byte;
    messageHMAC: array[20] of byte;
    toEncrypt: array[48] of byte;
    dataInFinal: array[64] of byte;
begin
   // prepare data
      //compute the final hashes
      for i := 0 to toHashMD5.dataLength - 1 do
        dataInFinal[i] := toHashMD5.dataIn[i];
        
      MD5SHAFinal( @dataInFinal,  @MD5Hash,  toHashMD5.dataLength,  1, 2);
      
      for i := 0 to toHashSHA1.dataLength - 1 do
        dataInFinal[i] := toHashSHA1.dataIn[i];
        
      MD5SHAFinal( @dataInFinal, @SHA1Hash, toHashSHA1.dataLength, 0, 1);
   
      // compute master secret
      CalculateMasterSecret(masterSecret);
      CalculateKeys(masterSecret);
     
      // compute verify data
      CalculateVerifyData(verifyData);
      // build a "client finished" message
      // the Plan:
      //   1. calculate HMAC on associated data + verify data
      //   2. Pad HMAC and verify data
      //   3. CBC encrypt padded message using client IV
      //   4. pack the message
      
      // 1. calculate HMAC on associated data + verify data
      Mem_Set(@toEncrypt, 0, 48);
      // associated data
      for i := 0 to 7 do
        toEncrypt[i] := 0;
      
      // 1. TLS record header
      toEncrypt[8]  := TLS_CONTENT_HANDSHAKE;     // content type = handshake, 0x16
      toEncrypt[9]  := TLS_VERSION_HIGH;
      toEncrypt[10] := TLS_VERSION_LO;
      toEncrypt[11] := $00;     // Message length Hi
      toEncrypt[12] := $10;     // Record  length Lo - 16 bytes
      
      // add TLS handshake header 14 00 00 0C
      toEncrypt[13] := TLS_HANDSHAKE_FINISHED;
      toEncrypt[14] := 0x00;
      toEncrypt[15] := 0x00;
      toEncrypt[16] := 0x0C;

      // append verify data
      for i := 0 to 11 do
        begin
           toEncrypt[17 + i] := verifyData[i];
        end;
        
      // calculate HMAC SHA-1 of the message
      HMAC_ShaMd5(@client_write_MAC_secret,  // Secret
                  20,             // Secret length
                  @toEncrypt,     // Data to hash
                  29           ,  // Data length
                  @messageHMAC ,  // Hash result
                  0);             // SHA-1
                  
      //2. concat verify data and HMAC
      Mem_Set(@toEncrypt, 0, 48);
      // add TLS handshake header 14 00 00 0C
      toEncrypt[0] := TLS_HANDSHAKE_FINISHED;
      toEncrypt[1] := 0x00;
      toEncrypt[2] := 0x00;
      toEncrypt[3] := 0x0C;
      
      // copy verify data
      for i := 0 to 11 do
        toEncrypt[4 + i] := verifyData[i];

      // copy HMAC
      for i := 0 to 19 do
        toEncrypt[16 + i] := messageHMAC[i];

      // pad with 0x0B to the first multiple of 16 which is 48
      for i := 36 to 47 do
        toEncrypt[i] := 0x0B;
        
      //3. CBC encrypt
      AES_128_CBC_encrypt(@client_write_key, @client_write_IV, @toEncrypt, 48);
      
      // 4. pack the message
      HTTP_data_out[0] := TLS_CONTENT_HANDSHAKE;     // content type = handshake, 0x16
      HTTP_data_out[1] := TLS_VERSION_HIGH;
      HTTP_data_out[2] := TLS_VERSION_LO;
      HTTP_data_out[3] := $00;     // Message length Hi
      HTTP_data_out[4] := $40;     // Record  length Lo - 64 bytes
      
      // append client IV
      for i := 0 to 15 do
        HTTP_data_out[5 + i] := client_write_IV[i];

      for i := 0 to 47 do
        HTTP_data_out[21 + i] := toEncrypt[i];

      result := 69;
end;

function ProcessServerHello(var startIndex: word): byte;
var serverHelloLength: dword;
    stopIndex, locali: word;
    counter: dword;
    serverHelloVersion: array[2] of byte;
    sessionID: array[32] of byte; // careful here, the length can be longer
    extensionsLength: word;
    debugMsg: string[32];
begin
  result := 2; // server hello expected
  serverCertificateStartIndex := 0;
 
  sessionIDLength := 0;
  Mem_Set(@ServerRandom, 0, 32);
  
   if     (host_response[startIndex] = TLS_CONTENT_HANDSHAKE) // this is a TLS response
      and (host_response[startIndex + 1] = TLS_VERSION_HIGH) // TLS 1.1
      and (host_response[startIndex + 2] = TLS_VERSION_LO) // TLS 1.1
      and (host_response[startIndex + 5] = TLS_HANDSHAKE_SERVER_HELLO)
      then
     begin
       startIndex := startIndex + 5; // start from server hello

       serverHelloLength := 0;
       Higher(serverHelloLength) := host_response[startIndex + 1];
       Hi(serverHelloLength) := host_response[startIndex + 2];
       lo(serverHelloLength) := host_response[startIndex + 3];
       serverHelloLength := serverHelloLength + 4; // include server hello id, plus 3 bytes for length
       stopIndex  := startIndex + serverHelloLength - 1;
       counter    := 0;
       for locali := startIndex to stopIndex do
         begin
           ClrWDT();
           // hash the entire message, without headers
           AddToHash(host_response[locali], 0); // SHA-1
           AddToHash(host_response[locali], 1); // MD5
           Uart3_write(host_response[locali]);
           
           // server hello version
           if counter = 4 then
             serverHelloVersion[0] := host_response[locali]
           else if counter = 5 then
             serverHelloVersion[1] := host_response[locali];

           //todo: compare server TLS version with what we want (prevent downgrade attack)

           //extract server random
           if (counter >= 6) and (counter <= 37) then // server Random
             begin
               ServerRandom[counter - 6] := host_response[locali];

               if counter = 37 then
                 begin
                   if UDP_debug <> 0 then
                      begin
                        debugMsg := 'Server Random';
                        out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
                        out_broadcast_local(33335, 32, serverRandom);
                      end;
                 end;
             end;
            
            // extract session id
           if counter = 38 then
             sessionIDLength := host_response[locali];

           if     (counter >= 39)
              and (counter <= 39 + sessionIDLength - 1)
              and (sessionIDLength <= 32)  then
             begin
               sessionID[counter - 39] := host_response[locali];
             end;

           // extract ciphercuite value
            // take two bytes of server's ciphesuite value
           if (counter =  39 + sessionIDLength) then
             serverCipherSuite[0] := host_response[locali];
           if (counter =  39 + sessionIDLength + 1) then
             serverCipherSuite[1] := host_response[locali];

           // server compression method
           if (counter =  39 + sessionIDLength + 2) then
            begin
              serverCompressionMethod := host_response[locali];

              if UDP_debug <> 0 then
                begin
                  debugMsg := 'sessionID';
                  out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
                  out_broadcast_local(33335, sessionIDLength, sessionID);

                  debugMsg := 'serverCipherSuite';
                  out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
                  out_broadcast_local(33335, 2, serverCipherSuite);

                  debugMsg := 'serverCompressionMethod N';
                  debugMsg[Str_Len(debugMsg) - 1] := serverCompressionMethod + 48;
                  out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
                end;
            end;

           if (counter =  39 + sessionIDLength + 2 + 1) then
             Hi(extensionsLength) := host_response[locali];
           if (counter =  39 + sessionIDLength + 2 + 2) then
             Lo(extensionsLength) := host_response[locali];

           if    (counter >=  39 + sessionIDLength + 2 + 3)
             and (counter <=  39 + sessionIDLength + 2 + 3 + extensionsLength - 1)
           then
             begin
               // todo: skiping server extensions
             end;

           inc(counter);
           dec(serverHelloLength);
           
           // done with server hello; server certificate starts
           if serverHelloLength = 0 then
             begin
               serverCertificateStartIndex := locali + 1;
               result := 0;
               exit;
             end;
         end;
     end;
end;

function ProcessServerCertificate(var startIndex: word): byte;
var debugMsg: string[32];
    serverCertificateLength: dword;
    parsedBytes : word;
    locali, stopIndex: word;
begin
  result := 3; // server certificate expected

  ServerCertificate.PublicKey.Key.Exponent[0] := 0;
  ServerCertificate.PublicKey.Key.Exponent[1] := 0;
  ServerCertificate.PublicKey.Key.Exponent[2] := 0;
  ServerCertificate.PublicKey.Key.Exponent[3] := 0;
  ServerCertificate.PublicKey.Key.ModulusLength  := 0;
  ServerCertificate.PublicKey.Key.ExponentLength := 0;
  for locali := 0 to 511 do
    ServerCertificate.PublicKey.Key.Modulus[locali] := 0;

  locali := startIndex;
  // server can send the header again
  if    (host_response[locali] = TLS_CONTENT_HANDSHAKE)
    and (host_response[locali + 1] = TLS_VERSION_HIGH)
    and (host_response[locali + 2] = TLS_VERSION_LO)
   then
    begin
      locali := locali + 5; // skip header
    end
  else
    begin
    end;

  if (host_response[locali] = TLS_HANDSHAKE_CERTIFICATE) then // server certificate 0x0b
    begin
      serverCertificateLength := 0;
      Higher(serverCertificateLength) := host_response[locali + 1];
      Hi(serverCertificateLength) := host_response[locali + 2];
      Lo(serverCertificateLength) := host_response[locali + 3];

      serverCertificateLength := serverCertificateLength + 4; // certificate id + 3 bytes for length
      
      // hello done starts after certificate stop index
      helloDoneStartIndex := locali + serverCertificateLength;
      
      // extract certificates
      startIndex := locali;
      stopIndex  := startIndex + word(serverCertificateLength) - 1;
      for locali := startIndex to stopIndex do
        begin
          // todo: keep the certificate somewhere, then compare it for security
          ClrWDT();
          AddToHash(host_response[locali], 0); // SHA-1
          AddToHash(host_response[locali], 1); // MD5
          UART3_Write(host_response[locali]);
        end;
      
      // move to the first cert. assuming it starts with 0x30
      locali := startIndex;
      while host_response[locali] <> 0x30 do
        begin
          inc(locali);
          if locali >= serverCertificateLength then
            break;
        end;
      startIndex := locali;
        
      X509Init(host_response, serverCertificateLength);
      if startIndex < serverCertificateLength then
        begin
          while startIndex < serverCertificateLength do
            begin
              parsedBytes := DecodeCertificate(host_response, ServerCertificate, startIndex);
              startindex := startindex + parsedBytes;
                begin
                  if ServerCertificate.PublicKey.Key.ModulusLength > 0 then // we have the key
                    if ServerCertificate.PublicKey.Key.ExponentLength > 0 then // we have the key
                      break;
                end;
            end;
              
          if (ServerCertificate.PublicKey.Key.ModulusLength = 0) or // we have the key
             (ServerCertificate.PublicKey.Key.ExponentLength = 0) then
            begin
              if UDP_debug <> 0 then
                begin
                  debugMsg := 'Server public key not found';
                  out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
                end;
              result := 8;
              exit;
            end;
              
          if UDP_debug <> 0 then
            begin
              debugMsg := 'Server public key and exp:';
              out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
              out_broadcast_local(33335, ServerCertificate.PublicKey.Key.ModulusLength, serverCertificate.PublicKey.Key.Modulus);
              out_broadcast_local(33335, ServerCertificate.PublicKey.Key.ExponentLength, serverCertificate.PublicKey.Key.Exponent);
            end;
          // success
          result := 0;
        end
      else
        begin
          if UDP_debug <> 0 then
            begin
              debugMsg := 'invalid server cert. length';
              out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
            end;
          result := 9;
        end;
    end
  else
    begin
      if UDP_debug <> 0 then
        begin
          debugMsg := 'expected server cert.';
          out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
        end;
      result := 10;
    end;
end;

function ProcessServerHelloDone(): byte;
var locali, startindex, stopindex: word;
    debugMsg: array[32] of char;
begin
  result := 4; // server hello done expected

  if helloDoneStartIndex = 0 then
    exit;
    
  // check if header exists
  if    (host_response[helloDoneStartIndex] = TLS_CONTENT_HANDSHAKE)
    and (host_response[helloDoneStartIndex + 1] = TLS_VERSION_HIGH)
    and (host_response[helloDoneStartIndex + 2] = TLS_VERSION_LO)
  then
    begin
      helloDoneStartIndex := helloDoneStartIndex + 5;
    end
  else
    begin
    end;

  if (host_response[helloDoneStartIndex] = TLS_HANDSHAKE_SERVER_HELLO_DONE) then // server hello done 0x0e
    begin
      startIndex := helloDoneStartIndex;
      stopIndex  := helloDoneStartIndex + 4 - 1; // 4 bytes in hello done
      for locali := startIndex to stopIndex do
         begin
           // hash
           AddToHash(host_response[locali], 0); // SHA-1
           AddToHash(host_response[locali], 1); // MD5
           Uart3_Write(host_response[locali]);
         end;

      result := 0;
    end
  else
    begin
      if UDP_debug <> 0 then
        begin
          debugMsg := 'expected Server hello done';
          out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
        end;
    end;
end;

//** error codes:
//  0 - no error
//  1 - unknown error
//  2 - server hello expected
//  3 - server certificate expected
//  4 - server hello done expected
//  5 - Client Key Exchange not sent
//  6 - Client ChangeCipher not sent
//  7 - Client Finished not sent
//  8 - Server's public key not detected
//  9 - Invalid server certificate length
// 10 - Expected server certificate
function Open_SSL(port : word) : boolean;
var
    serverResponseLength: word;
    locali: word;
    startIndex, stopIndex: word;
    ptr: ^byte;
    messageLength: word;
    debugMsg: string[32];
    res: byte;
begin
  result := 1;
  certificate_len := 0;
  if OpenTCPConnection_SSL(port) <> 0 then
    begin
      toHashMD5.firstBlock := TRUE; // start a new hash
      toHashMD5.dataLength := 0;
      
      toHashSHA1.firstBlock := TRUE; // start a new hash
      toHashSHA1.dataLength := 0;
      
      messageLength := CreateClientHello();
      if SendMessage(messageLength, TRUE) then
        begin
          Wait_With_Eth(500);
          if UDP_debug <> 0 then
            begin
              out_broadcast_local(33335, host_response_len_ssl, host_response);
            end;
          
          // **  server response consists of three parts:
          //    1. Server hello
          //    2. Server certificate
          //    3. Server hello done
          
          serverCertificateStartIndex := 0;
          helloDoneStartIndex := 0;
          
          // 1. Server hello
            begin
              locali := 0;
              result := ProcessServerHello(locali);
            end;
          
          // 2. Server certificate
          if result = 0 then
            begin
              result := ProcessServerCertificate(serverCertificateStartIndex);
            end;
            
         // 3. Server hello done
          if result = 0 then
            begin
              result := ProcessServerHelloDone();
            end;

          if result <> 0 then exit;
          
          // prepare Client Key Exchange message
          messageLength := CreateClientKeyExchange();
          res := SendMessage(messageLength, false);
          Wait_With_Eth(1000);
          if res <> 0 then
            begin
              host_response_len_ssl := 0;
              messageLength := CreateChangeCipher();
              res := SendMessage(6, false);
              if res then
                begin
                  Wait_With_Eth(500);
                  if UDP_debug <> 0 then
                    begin
                      debugMsg := 'Change Cipher Sent';
                      out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
                    end;
                  
                  messageLength := CreateClientFinished();
                  if SendMessage(messageLength, true) <> 0 then
                    begin
                      Wait_With_Eth(500);
                      if UDP_debug <> 0 then
                        begin
                          debugMsg := 'client Finished SENT';
                          out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
                        end;
                    end
                  else
                    begin
                      result := 7; // client Finished not sent
                      if UDP_debug <> 0 then
                        begin
                          debugMsg := 'client Finished NOT Sent';
                          out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
                        end;
                    end;
                end
              else
                begin
                  result := 6; // client ChangeCipher not sent
                  if UDP_debug <> 0 then
                    begin
                      debugMsg := 'Change Cipher NOT Sent';
                      out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
                    end;
                end;
            end
          else
            begin
              result := 5; // clientkey exchange not sent
              if UDP_debug <> 0 then
                  begin
                    debugMsg := 'clientkey exchange NOT Sent';
                    out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
                  end;
            end;
        end;


    end;
end;

// - labelLength must be even and it must not include a trailing zero
// - secretKeyLength must be even
// - prfLength is of max size of 255
procedure P_Hash
             (secretKey: ^byte; secretKeyLength: word;
              seed     : ^byte; seedLength: word;
              hashOut  : ^byte; hashOutLength: word;
              sha1Md5  : byte);
var i: byte;
    aHash, hHash: array[20] of byte;
    aAndSeed: array[255] of byte;
    hashSize: byte;
    msg: string[5];
    seedArray: array[128] of byte;
begin
{Word2Str(secretKeyLength, msg);
  UART3_Write_Text(' secretKeyLength: ');
  UART3_Write_Text(msg);

  Word2Str(seedLength, msg);
  UART3_Write_Text(' seedLength: ');
  UART3_Write_Text(msg);

  Word2Str(hashOutLength, msg);
  UART3_Write_Text(' hashOutLength: ');
  UART3_Write_Text(msg);}
  
  for i := 0 to seedLength - 1 do
    begin
      seedArray[i] := seed^;
      inc(seed);
    end;
      
  //uart3_write_text('here 1');
  if sha1Md5 = 0 then
    hashSize := 20
  else
    hashSize := 16;

  // A0 = seed
  // A1 = hmac(secret, seed) = hmac(secret, A0)
  // P_Hash1 = hmac(secret, A1 + seed);

  // A2 = hmac(secret, A1)
  // P_Hash2 = hmac(secret, A2 + seed);
  
  // A1
  HMAC_ShaMd5(secretKey, secretKeyLength,
              @seedArray, seedLength,
              @aHash, // this is A1
              sha1Md5);
  // build A1 + seed
  for i := 0 to hashSize - 1 do
    aAndSeed[i] := aHash[i];
  for i := 0 to seedLength - 1 do
    begin
      aAndSeed[i + hashSize] := seedArray[i];
    end;

  while hashOutLength > 0 do
    begin
      // calculate PHash = hmac(secret, A + seed)
      HMAC_ShaMd5(secretKey, secretKeyLength,
                  @aAndSeed, hashSize + seedLength,
                  @hHash,   // this is P_Hash
                  sha1Md5);
      for i := 0 to hashSize - 1 do
        begin
          hashOut^ := hHash[i];
          inc(hashOut);
          dec(hashOutLength);
          if hashOutLength = 0 then
            break;
        end;
      // Set A for next iteration
      // A(i) = HMAC_hash( secret, A(i-1) )
      HMAC_ShaMd5(secretKey, secretKeyLength,
                  @aHash, hashSize,
                  @hHash,
                  sha1Md5);
      for i := 0 to hashSize - 1 do
        begin
          aAndSeed[i] := hHash[i];
          aHash[i]    := hHash[i];
        end;
      for i := 0 to seedLength - 1 do
        begin
          aAndSeed[i + hashSize] := seedArray[i];
        end;
    end;
  // uart3_write_text(' here 5 ');
end;

// - labelLength must be even and it must not include a trailing zero
// - secretKeyLength must be even
// - prfLength is of max size of 255
procedure PRF(secretKey: ^byte; secretKeyLength: word;
              aLabel   : ^byte; labelLength: word;
              seed     : ^byte; seedLength: word;
              PRFOut   : ^byte; prfLength: word);
var halfSecretLength: word;
    sha1Out: array[255] of byte;
    i : byte;
    msg : string[5];
    concat: string[255];
begin
  halfSecretLength := (secretKeyLength div 2) + (secretKeyLength mod 2);
  
  for i := 0 to labelLength - 1 do
    begin
      concat[i] := aLabel^;
      inc(aLabel);
    end;
  for i := 0 to  seedLength- 1 do
    begin
      concat[i + labelLength] := seed^;
      inc(seed);
    end;
  
  P_Hash(secretKey, halfSecretLength, 
         @concat, labelLength + seedLength,
         PRFOut, prfLength, 
         1); // md5
         
  P_Hash(secretKey + (secretKeyLength div 2), halfSecretLength, 
         @concat, labelLength + seedLength,
         @sha1Out, prfLength, 
         0); // sha-1
  for i := 0 to prfLength - 1 do
    begin
      PRFOut^ := PRFOut^ xor sha1Out[i];
      inc(PRFOut);
    end;
end;

end.
