unit unSSL_TLS;

uses dspic_additional_string_library,lib_Delays_LIO,def_io,lib1_enc600_V3_5_b,
     enc_lib_user,lib2_enc600_V3_5_b,df_lib_SPI1,crc16_lib,
     Tftp_Server,HTTP_Send,definitions_ENC600,unX509Certificate;

procedure Random_Init;
procedure Random_Array_32(d_in : ^byte);
procedure Random_Array_46(d_in : ^byte);
procedure MD5SHA(dataIn : ^char; dataLength : word; shaMd5
                   , restoreContextID // 0 - none
                                      // 1 - SHA 1
                                      // 2 - MD5
                   , saveContextID    // 0 - none
                                      // 1 - SHA 1
                                      // 2 - MD5
                   : byte);
procedure MD5SHAFinal(dataIn, dataOut : ^char; dataLength : word; shaMd5, contextID: byte);
procedure HMAC_ShaMd5(secretKey : ^byte; secretKeyLength : word; textToHash : ^byte;
                      textLength : word; hmacResult : ^byte; shaMd5 : byte);
function  AES_128_CBC_encrypt(key16, iv16, text : ^char; text_len : word): byte;
function  AES_128_CBC_decrypt(key16, iv16, text : ^char; text_len : word): byte;
function  modexp(var y : array[128] of byte;
                 var e : array[128] of byte; e_len : word;
                 var x : array[128] of byte; x_len : word;
                 var m : array[128] of byte; m_len : word): byte;
procedure SSL_Init;
procedure HTTPProcDataIn_SSL(len_ : word; j : byte);
function  OpenTCPConnection_SSL(port : word) : boolean;
function  Open_SSL(port : word) : boolean;
function  PRF(secretKey: ^byte; secretKeyLength: word;
              aLabel: ^byte; labelLength: word;
              seed: ^byte; seedLength: word;
              prfOut: ^byte; prfLength: word): byte;

procedure AddToHash(hashByte: byte; ShaMD5: byte);
function  TLSSend128(var outData: array[1024] of byte; dataLength: word): byte;
function  TLSSend(var outData: array[1024] of byte; dataLength: word): byte;
function  TLSReceive(var dataLength: word): byte;

type TtoHash = record
  hashed: boolean;           // indicates if dataIn is hashed
  firstBlock: boolean;       // if set, then hash engine is reset
  dataLength: byte;          // current length of dataIn
  dataIn: array[65] of byte; // data to be hashed, 65 because we will always transfer one byte to the next iteration
end;

Type TTlsConnection = record
    toHashMD5, toHashSHA1: TtoHash;
    ServerCertificate: TX509Certificate;
    connectionState: byte;
    serverCipherSuite: array[2] of byte;
    serverCompressionMethod: byte;
  end;
  
// a globally visible variable
var tlsConnection: TTlsConnection;

const TLS_CONNECTION_STATE_DISCONNECTED = 0;
      TLS_CONNECTION_STATE_HANDSHAKING  = 1;
      TLS_CONNECTION_STATE_CONNECTED    = 2;

implementation

// NOTE: Tracing sensitive information in production can be a disaster.
// However, during a debug some information is needed.
// The following directive activates tracing of sensitive info.
// In production code you certainly do not want this directive to be enabled!
{$DEFINE TraceSensitiveInformation}

const HASHLST = 12;   // ECON1
      HASHOP  = 13;   // ECON1
      HASHEN  = 14;   // ECON1
      SHA1MD5 = 12;   // ECON2
      HASHIF  = 13;   // EIR
      
// handshake type
const TLS_HANDSHAKE_HELLO_REQUEST       =  0x00; //  0
      TLS_HANDSHAKE_CLIENT_HELLO        =  0x01; //  1
      TLS_HANDSHAKE_SERVER_HELLO        =  0x02; //  2
      TLS_HANDSHAKE_CERTIFICATE         =  0x0B; // 11
      TLS_HANDSHAKE_SERVER_KEY_EXCHANGE =  0x0C; // 12
      TLS_HANDSHAKE_CERTIFICATE_REQUEST =  0x0D; // 13
      TLS_HANDSHAKE_SERVER_HELLO_DONE   =  0x0E; // 14
      TLS_HANDSHAKE_CERTIFICATE_VERIFY  =  0x0F; // 15
      TLS_HANDSHAKE_CLIENT_KEY_EXCHANGE =  0x10; // 16
      TLS_HANDSHAKE_FINISHED            =  0x14; // 20

// content type
const TLS_CONTENT_CHANGE_CIPHER         =  0x14;
      TLS_CONTENT_ALERT                 =  0x15;
      TLS_CONTENT_HANDSHAKE             =  0x16;
      TLS_CONTENT_APPLICATION_DATA      =  0x17;

const TLS_VERSION_HIGH        = 0X03;  // TLS 1.1
      TLS_VERSION_LO          = 0X02;

const
      TLS_ALERT_CLOSE_NOTIFY            =   0;
      TLS_ALERT_UNEXPECTED_MESSAGE      =  10;
      TLS_ALERT_BAD_RECORD_MAC          =  20;
      TLS_ALERT_DECRYPTION_FAILED       =  21;
      TLS_ALERT_RECORD_OVERFLOW         =  22;
      TLS_ALERT_DECOMPRESSION_FAILURE   =  30;
      TLS_ALERT_HANDSHAKE_FAILURE       =  40;
      TLS_ALERT_BAD_CERTIFICATE         =  42;
      TLS_ALERT_UNSUPPORTED_CERTIFICATE =  43;
      TLS_ALERT_CERTIFICATE_REVOKED     =  44;
      TLS_ALERT_CERTIFICATE_EXPIRED     =  45;
      TLS_ALERT_CERTIFICATE_UNKNOWN     =  46;
      TLS_ALERT_ILLEGAL_PARAMETER       =  47;
      TLS_ALERT_UNKNOWN_CA              =  48;
      TLS_ALERT_ACCESS_DENIED           =  49;
      TLS_ALERT_DECODE_ERROR            =  50;
      TLS_ALERT_DECRYPT_ERROR           =  51;
      TLS_ALERT_EXPORT_RESTRICTION      =  60;
      TLS_ALERT_PROTOCOL_VERSION        =  70;
      TLS_ALERT_INSUFFICIENT_SECURITY   =  71;
      TLS_ALERT_INTERNAL_ERROR          =  80;
      TLS_ALERT_USER_CANCELED           =  90;
      TLS_ALERT_NO_RENEGOTIATION        = 100;


      
type TPreMasterSecret = record
  clientVersion: array[2] of byte;
  random: array[46] of byte;
end;

var m_z,m_w,m_r : dword;
var MD5_buff, SHA1_buff : array[28] of byte;

var MD5Hash: array[16] of char;
var SHA1Hash: array[20] of char;
var masterSecret: array[48] of byte;
var preMasterSecret: TPreMasterSecret;

var client_write_MAC_secret : array[0..19] of byte;
var server_write_MAC_secret : array[0..19] of byte;
var client_write_key        : array[0..15] of byte;
var server_write_key        : array[0..15] of byte;
var client_write_IV         : array[0..15] of byte;
var server_write_IV         : array[0..15] of byte;

var serverRandom: array[32] of byte;
var clientRandom: array[32] of byte;

var sequenceNumber: array[8] of byte;

var serverCertificateStartIndex: word;
    helloDoneStartIndex: word;
    certificateRequestIndex: word;


procedure Random_Init;
begin
  LoWord(m_z) := TMR1;
  HiWord(m_z) := TMR1+127;
  LoWord(m_w) := TMR1+369;
  HiWord(m_w) := TMR1+768;
end;

function Random : dword;
var i: byte;
    an1Input: word;
begin
  m_z := 36969 * (m_z and 65535) + (m_z shr 16);
  m_w := 18000 * (m_w and 65535) + (m_w shr 16);
  result := (m_z shl 16) + m_w;
 {exit;
  // another way: read an analog pin and take the lowest bit (it fluctuates if opened)
  // adc1_init() must be called before using the ADC module
  result := 0;
  for i := 0 to 31 do
    begin
      an1Input := ADC1_Get_Sample(8);
      result := result or an1Input.0; // take bit 0 (should  be a Random fluctuation)
      result := result shl 1;         // shift left until all bits filled in with Random bit
    end;}
end;

procedure AnalyzeRandom;
begin
//  Random_Init();
  m_r := Random;
  while ((Lo(m_r) = 0) or (Hi(m_r) = 0) or (Higher(m_r) = 0) or (Highest(m_r) = 0)) do m_r := Random;
end;

// big endian 8-byte variable
procedure IncrementSequenceNumber();
begin
  inc(sequenceNumber[7]);
  if (sequenceNumber[7] = 0) then
    begin
      inc(sequenceNumber[6]);
      if (sequenceNumber[6] = 0) then
        begin
          inc(sequenceNumber[5]);
          if (sequenceNumber[5] = 0) then
            begin
              inc(sequenceNumber[4]);
              if (sequenceNumber[4] = 0) then
                begin
                  inc(sequenceNumber[3]);
                  if (sequenceNumber[3] = 0) then
                    begin
                      inc(sequenceNumber[2]);
                      if (sequenceNumber[2] = 0) then
                        begin
                          inc(sequenceNumber[1]);
                          if (sequenceNumber[1] = 0) then
                            begin
                              inc(sequenceNumber[0]);
                            end;
                        end;
                    end;
                end;
            end;
        end;
    end;
end;

procedure ClearSequenceNumber();
var i: byte;
begin
  for i := 0 to 7 do
    sequenceNumber[i] := 0;
end;

// number of bytes must be divisible by 4
procedure Random_Array(randomData : ^byte; numberOfBytes: byte);
var i : word;
begin
  numberOfBytes := numberOfBytes div 4;
  i := 0;
  while i < numberOfBytes do
    begin
      AnalyzeRandom;
      randomData^ := Lo(m_r);
      inc(randomData);
      randomData^ := Hi(m_r);
      inc(randomData);
      randomData^ := Higher(m_r);
      inc(randomData);
      randomData^ := Highest(m_r);
      inc(randomData);
      inc(i);
    end;
end;

procedure Random_Array_32(d_in : ^byte);
var i : word;
begin
  i := 0;
  while i < 8 do
    begin
      AnalyzeRandom;
      d_in^ := Lo(m_r);
      inc(d_in);
      d_in^ := Hi(m_r);
      inc(d_in);
      d_in^ := Higher(m_r);
      inc(d_in);
      d_in^ := Highest(m_r);
      inc(d_in);
      inc(i);
    end;
end;

procedure Random_Array_46(d_in : ^byte);
var i : byte;
begin
  i := 0;
  while i < 11 do
    begin
      AnalyzeRandom;
      d_in^ := Lo(m_r);
      inc(d_in);
      d_in^ := Hi(m_r);
      inc(d_in);
      d_in^ := Higher(m_r);
      inc(d_in);
      d_in^ := Highest(m_r);
      inc(d_in);
      inc(i);
    end;
  // two more bytes to make it 46
  AnalyzeRandom;
  d_in^ := Lo(m_r);
  inc(d_in);
  d_in^ := Hi(m_r);
end;

procedure dma_write(addr : word; d_in : ^char; len : word);
begin
  CopyRamToEthMem(d_in, $680, len);
  CopyEthMemToEthMem($680,addr,len);
end;

procedure dma_read(addr : word; d_out : ^char; len : word);
begin
  CopyEthMemToEthMem(addr,$680,len);
  CopyEthMemToRam($680,d_out,len);
end;

procedure MD5SHA(  dataIn : ^char;
                   dataLength : word; 
                   shaMd5             // 0 - SHA1, 1 - MD5
                   , restoreContextID // 0 - none
                                      // 1 - SHA 1
                                      // 2 - MD5
                   , saveContextID    // 0 - none
                                      // 1 - SHA 1
                                      // 2 - MD5
                   : byte);
var i : word;
    buf : word;
begin
  buf := Eth_ReadReg(ECON2_);
  if shaMd5 = 1 then
    begin
      buf.SHA1MD5 := 0;           // MD5
      shaMd5 := 16;
    end
  else
    begin
      buf.SHA1MD5 := 1;           // SHA1
      shaMd5 := 20;
    end;
  Eth_WriteReg(ECON2_, buf);
  
  buf := Eth_ReadReg(ECON1_);

  if restoreContextID = 2 then
    begin
      dma_write(0x7A40, @MD5_buff, 28);
      buf.HASHOP := 1; // continue prev hash
    end
  else if restoreContextID = 1 then
    begin
      dma_write(0x7A40, @SHA1_buff, 28);
      buf.HASHOP := 1; // continue prev hash
    end
  else
    begin
      buf.HASHOP := 0; // begin a new hash
    end;

  buf.HASHEN := 1;
  i := 0;
  if dataLength > 64 then
    begin
      buf.HASHLST := 0;           // HASHLST

      Eth_WriteReg(ECON1_, buf);
      while dataLength > 64 do
        begin
          buf := Eth_ReadReg(EIR_);
          buf.HASHIF := 0;           // HASHIF
          Eth_WriteReg(EIR_, buf);
          dma_write(0x7A00, dataIn + i, 64);
          while (Eth_ReadReg(EIR_) and $2000) = 0 do delayms(1); // HASHIF
          dataLength := dataLength - 64;
          i := i + 64;
        end;

      if saveContextID = 2 then
        begin
          dma_read(0x7A70, @MD5_buff, 28);
        end
      else if saveContextID = 1 then
        begin
          dma_read(0x7A70, @SHA1_buff, 28);
        end;
    end;

  buf := Eth_ReadReg(ECON1_);
  buf.HASHEN := 0;           // HASHEN
  Eth_WriteReg(ECON1_, buf);
end;

procedure MD5SHAFinal(dataIn, dataOut : ^char; dataLength : word; shaMd5, restoreContextID: byte);
var buf : word;
begin
  buf := Eth_ReadReg(ECON2_);
  if shaMD5 = 1 then // MD5
    begin
      shaMD5 := 16;
      buf.SHA1MD5 := 0;
    end
  else // SHA1
    begin
      shaMD5 := 20;
      buf.SHA1MD5 := 1;
    end;
  Eth_WriteReg(ECON2_, buf);
  
  buf := Eth_ReadReg(ECON1_);
  if restoreContextID = 2 then
    begin
      dma_write(0x7A40, @MD5_buff, 28);
      buf.HASHOP := 1; // continue prev hash
    end
  else if restoreContextID = 1 then
    begin
      dma_write(0x7A40, @SHA1_buff, 28);
      buf.HASHOP := 1; // continue prev hash
    end
  else
    begin
      buf.HASHOP := 0; // begin a new hash
    end;
  
  buf.HASHEN := 1;
  buf.HASHLST := 1;
  Eth_WriteReg(ECON1_, buf);
  
  buf := Eth_ReadReg(EIR_);
  buf.HASHIF := 0;
  Eth_WriteReg(EIR_, buf);
  
  if dataLength > 0 then  // must be <= 64
    begin
      dma_write(0x7A00, dataIn, dataLength);
      while (Eth_ReadReg(EIR_) and $2000) = 0 do // HASHIF
        delayms(1);
    end;
  dma_read(0x7A70, dataOut, shaMD5);
  buf := Eth_ReadReg(ECON1_);
  buf.HASHEN := 0;
  Eth_WriteReg(ECON1_, buf);
end;


//******************************************************************************
//
//
//
//******************************************************************************
procedure AddToHash(hashByte: byte; ShaMD5: byte);
var save, restore: byte;
    tmp: array[64] of byte;
    i: byte;
begin
  if ShaMD5 = 0 then
    begin
      tlsConnection.toHashSHA1.hashed := false; // new data is pending
      tlsConnection.toHashSHA1.dataIn[tlsConnection.toHashSHA1.dataLength] := hashByte;
      tlsConnection.toHashSHA1.dataLength := tlsConnection.toHashSHA1.dataLength + 1;
      if (tlsConnection.toHashSHA1.dataLength > 64) then  // do it only if another byte is pending after this block(because of the call to final)
        begin // hash the current block
          save := 1; // always save the context
          if tlsConnection.toHashSHA1.firstBlock <> 0 then
            begin // we do not restore on the first block
              restore := 0;
            end
          else
            begin
              restore := 1;
            end;
          for i := 0 to 63 do
            tmp[i] := tlsConnection.toHashSHA1.dataIn[i];
          MD5SHA(@tmp, // data to be hashed
                 65,                    // 64B actually, but the extra one will trigger a proper procedure
                 0,                     // SHA1
                 restore,               // context
                 save                   // context
                 );
          tlsConnection.toHashSHA1.dataLength := 1; // one byte remained, move it to next iteration
          tlsConnection.toHashSHA1.dataIn[0] := tlsConnection.toHashSHA1.dataIn[64]; // this is the orphan that was not hashed
          tlsConnection.toHashSHA1.hashed := true;    // not really needed?
          tlsConnection.toHashSHA1.firstBlock := false;
        end;
    end
  else
    begin
      tlsConnection.toHashMD5.hashed := false; // new data is pending
      tlsConnection.toHashMD5.dataIn[tlsConnection.toHashMD5.dataLength] := hashByte;
      tlsConnection.toHashMD5.dataLength := tlsConnection.toHashMD5.dataLength + 1;
      if (tlsConnection.toHashMD5.dataLength > 64) then // do it only if another byte is pending after this block (because of the call to final)
        begin // hash the current block
          save := 2; // always save the context
          if tlsConnection.toHashMD5.firstBlock <> 0 then
            begin // we do not restore on the first block
              restore := 0;
            end
          else
            begin
              restore := 2;
            end;
          for i := 0 to 63 do
            tmp[i] := tlsConnection.toHashMD5.dataIn[i];
          MD5SHA(@tmp, // data to be hashed
                 65,                   // 64B actually, but the extra one will trigger a proper procedure
                 1,                    // MD5
                 restore,              // context
                 save);                // context

          tlsConnection.toHashMD5.dataLength := 1; // one byte remained, move it to next iteration
          tlsConnection.toHashMD5.dataIn[0] := tlsConnection.toHashMD5.dataIn[64]; // this is the orphan that was not hashed
                                                       // move it to the next block
          tlsConnection.toHashMD5.hashed := true;    // not really needed?
          tlsConnection.toHashMD5.firstBlock := false;
        end;
    end;
end;

procedure HMAC_ShaMd5(secretKey : ^byte; secretKeyLength : word; textToHash : ^byte;
                      textLength : word; hmacResult : ^byte; shaMd5 : byte);
const BLOCK_SIZE = 64;
var ipad, opad : array[BLOCK_SIZE + 1] of char;
    i : word;
    isha: array [20] of byte;
    buf: array[BLOCK_SIZE] of byte;
    digestSize: byte;
    secretKeyHash: array[BLOCK_SIZE] of byte;
    saveContext, restoreContext: byte;
begin
  if shaMd5 = 0 then
    begin
      digestSize := 20;
      restoreContext := 1;
      saveContext := 1;
    end
  else
    begin
      digestSize := 16;
      restoreContext := 2;
      saveContext := 2;
    end;
    
  if secretKeyLength > BLOCK_SIZE then
    begin
        MD5SHA(secretKey, secretKeyLength, shaMd5, 0, saveContext);
        i := secretKeyLength div BLOCK_SIZE;
        i := i * BLOCK_SIZE;                     // completed bytes
        secretKeyLength := secretKeyLength mod BLOCK_SIZE; // remaining bytes

        MD5SHAFinal(secretKey + i, @secretKeyHash, secretKeyLength, shaMd5, restoreContext);
    end
  else
    begin
      for i := 0 to secretKeyLength - 1 do
        begin
          secretKeyHash[i] := secretKey^;
          inc(secretKey);
        end;
    end;

  //**** Inner Digest ****/
  Mem_Set(@ipad, 0x36, BLOCK_SIZE);
  Mem_Set(@opad, 0x5c, BLOCK_SIZE);
   
  for i := 0 to secretKeyLength - 1 do
     begin
       ipad[i] := ipad[i] xor secretKeyHash[i];
       opad[i] := opad[i] xor secretKeyHash[i];
     end;
  
  i := 0;
  MD5SHA(@ipad, BLOCK_SIZE + 1, shaMd5, 0, saveContext);
  if textLength > BLOCK_SIZE then
     begin
        MD5SHA(textToHash, textLength, shaMd5, restoreContext, saveContext);
        i := textLength div BLOCK_SIZE;
        i := i * BLOCK_SIZE;                     // completed bytes
        textLength := textLength mod BLOCK_SIZE; // remaining bytes
     end;
  MD5SHAFinal(textToHash + i, @isha, textLength, shaMd5, restoreContext);

  //**** Outter Digest ****
  MD5SHA(@opad, BLOCK_SIZE + 1, shaMd5, 0, restoreContext);
  MD5SHAFinal(@isha, hmacResult, digestSize, shaMd5, restoreContext);
end;

// returns number of errors
function AES_128_CBC_encrypt(key16, iv16, text : ^char; text_len : word): byte;
var blocks, i, buf : word;
begin
  result := 1; // prepare for errors
  if (text_len mod 16) = 0 then 
    nop 
  else 
    exit;

  blocks := text_len div 16;

  while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for AES engine to be free...

  buf := Eth_ReadReg(ECON2_);
  buf.0 := 0;           // AESLEN 128-bit key
  buf.1 := 0;           // AESLEN 128-bit key
  Eth_WriteReg(ECON2_, buf);

  dma_write(0x7C00, key16, 16);

  buf := Eth_ReadReg(ECON1_);
  buf.11 := 1;           // AESST
  Eth_WriteReg(ECON1_, buf);
  while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for key to be loaded

  buf := Eth_ReadReg(ECON1_);
  buf.9 := 1;           // AESOP CBC encrypt
  buf.10 := 0;           // AESOP CBC encrypt
  Eth_WriteReg(ECON1_, buf);

  dma_write(0x7C20, iv16, 16);

  i := 0;
  while i < blocks do
    begin
      // write the next block ...
      dma_write(0x7C30, text + i*16, 16);
      buf := Eth_ReadReg(ECON1_);
      buf.11 := 1;           // AESST start encryption
      Eth_WriteReg(ECON1_, buf);
      while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for completion
      dma_read(0x7C20, text + i*16, 16);
      inc(i);
  end;
  result := 0; // no errors
end;

// returns number of errors
function AES_128_CBC_decrypt(key16, iv16, text : ^char; text_len : word) : byte;
var blocks, i, buf : word;
    newIv: array[16] of byte;
    k: byte;
    p : ^byte;
begin
  result := 1; // prepare for errors
  if (text_len mod 16) = 0 then 
    nop 
  else 
    exit;

  blocks := text_len div 16;

  while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for AES engine to be free...

  buf := Eth_ReadReg(ECON2_);
  buf.0 := 0;           // AESLEN 128-bit key
  buf.1 := 0;           // AESLEN 128-bit key
  Eth_WriteReg(ECON2_, buf);

  dma_write(0x7C00, key16, 16);

  buf := Eth_ReadReg(ECON1_);
  buf.11 := 1;           // AESST
  Eth_WriteReg(ECON1_, buf);
  while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for key to be loaded

  buf := Eth_ReadReg(ECON1_);
  buf.9 := 0;           // AESOP CBC decrypt
  buf.10 := 1;          // AESOP CBC decrypt
  Eth_WriteReg(ECON1_, buf);

  dma_write(0x7C30, iv16, 16);
  p := text;
  i := 0;
  while i < blocks do
    begin
      // write the next block ...
      dma_write(0x7C20, text + i*16, 16);
      for k := 0 to 15 do
        begin
          newIV[k] := p^;
          inc(p);
        end;
      buf := Eth_ReadReg(ECON1_);
      buf.11 := 1;           // AESST start decryption
      Eth_WriteReg(ECON1_, buf);
      while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for completion
      dma_read(0x7C40, text + i*16, 16);
//    If another block is to be decrypted, copy the
//      ciphertext message from this block to TEXTB at
//      7C30h. The ciphertext from this block becomes
//      the IV for the following one.
      dma_write(0x7C30, @newIv, 16);
      inc(i);
    end;
  result := 0; // no errors
end;

// Error codes:
// 0 - no error
// 1 - modulus not a power of 2
// 2 - exponent and key must be stricly less than m
// 3 - e and x must be strictly less than m
// 4 - For the Modular Exponentiation engine to work correctly, the
//      Most Significant (MSb) bit of M must be set."

function modexp (var y : array[128] of byte;
                 var e : array[128] of byte; e_len : word;
                 var x : array[128] of byte; x_len : word;
                 var m : array[128] of byte; m_len : word): byte;
var buf : array[128] of byte;
    buf1 : word;
begin
  result := 255; // failed
  // Only 512, 768, and 1024 bit moduli are supported
  if (m_len <> 64) and (m_len <> 96) and (m_len <> 128) then 
    begin
      result := 1;
      exit;
    end;

// e and x must be strictly less than m
{if (e_len > m_len) or (x_len > m_len) then
    begin
      result := 3;
      exit;
    end;}

{ datasheet 15.1
      "For the Modular Exponentiation engine to work correctly, the
      Most Significant (MSb) bit of M must be set."
}

  if (m[0] and 0x80) = 0 then
    begin
      result := 4;
      exit;
    end;

  // left-pad e, x with zeros
  Mem_Set(@buf, 0, m_len);
  Mem_Cpy(@buf + m_len - e_len, @e, e_len);
  dma_write(0x7800, @buf, m_len);

  Mem_Set(@buf, 0, m_len);
  Mem_Cpy(@buf + m_len - x_len, @x, x_len);
  dma_write(0x7880, @buf, m_len);

  dma_write(0x7900, @m, m_len);

  buf1 := Eth_ReadReg(ECON2_);
  buf1.2 := 0;                              // MODLEN 64
  buf1.3 := 0;                              // MODLEN 64
  if m_len = 96 then buf1.2 := 1            // MODLEN 96
  else if m_len = 128 then buf1.3 := 1;     // MODLEN 128
  Eth_WriteReg(ECON2_, buf1);

  buf1 := Eth_ReadReg(ECON1_);
  buf1.15 := 1;           // MODEXST enable modexp engine
  Eth_WriteReg(ECON1_, buf1);
  while (Eth_ReadReg(ECON1_) and $8000) <> 0 do delayms(1);

  dma_read(0x7880, @y, m_len);
  result := 0;// success
end;

procedure out_broadcast_local(port,len : word; var d_in : array[4096] of byte);
var broadcast_ip : array[4] of byte;
var i,j : word;
    buf : string[1300];
begin
  broadcast_ip[0] := 255;
  broadcast_ip[1] := 255;
  broadcast_ip[2] := 255;
  broadcast_ip[3] := 255;

  j := 0;
  while len <> 0 do
    begin
      i := len;
      if i > 1280 then i := 1280;

      Mem_Cpy(@buf,@d_in[j],i);

      Send_UDP_Broadcast(broadcast_ip,port,port,i,buf);
      Do_EthernetProc;

      j := j + i;
      len := len - i;
    end;
end;

// if current debug level is higher than requested
//  then print out debug information
// * traceType:
//   1 - error
//   2 - warning
//   4 - debug
//   8 - log
// the values are OR-ed together to make combinations
procedure TraceOut(var debugData: array[4096] of byte; debugDataLength: word; traceLevel, traceType: byte);
begin
  if (flashData.debugLevel >= traceLevel) then
    begin
      {UART3_Write(udpDebugLevel);
      UART3_Write(traceLevel);
      UART3_Write(udpTraceType);}
    if ((traceType and flashData.debugType) = traceType) then
      begin
        out_broadcast_local(33335, debugDataLength, debugData);
      end;
    end;
end;

procedure SSL_Init;
var locali: word;
begin
  HTTP_send_Port_ssl := TMR1 + 23456;
  host_response_len_ssl := 0;
  tlsConnection.connectionState := TLS_CONNECTION_STATE_DISCONNECTED;
  tlsConnection.toHashMD5.firstBlock := TRUE; // start a new hash
  tlsConnection.toHashMD5.dataLength := 0;

  tlsConnection.toHashSHA1.firstBlock := TRUE; // start a new hash
  tlsConnection.toHashSHA1.dataLength := 0;
  tlsConnection.ServerCertificate.PublicKey.Key.Exponent[0] := 0;
  tlsConnection.ServerCertificate.PublicKey.Key.Exponent[1] := 0;
  tlsConnection.ServerCertificate.PublicKey.Key.Exponent[2] := 0;
  tlsConnection.ServerCertificate.PublicKey.Key.Exponent[3] := 0;
  tlsConnection.ServerCertificate.PublicKey.Key.ModulusLength  := 0;
  tlsConnection.ServerCertificate.PublicKey.Key.ExponentLength := 0;
  for locali := 0 to 511 do
    tlsConnection.ServerCertificate.PublicKey.Key.Modulus[locali] := 0;
  
  Random_Init();
  ClearSequenceNumber();
end;

procedure HTTPProcDataIn_SSL(len_ : word; j : byte);
var max_len : word;
var debugMsg: string[32];
label next_;
begin
  Socket[j].Keep_Alive := true;


  if host_response_len_ssl >= 6144 {4096} then
    begin
//      UART3_Write_Text('Rx message too long');
      exit;
    end;

  if host_response_len_ssl <> 0 then    // one packet arrived
    begin
      max_len := 6144 {4096} - host_response_len_ssl;
      if len_ > max_len then len_ := max_len;
    end;

  CopyEthMem_CPToRam(@host_response[host_response_len_ssl], len_);
  host_response_len_ssl := host_response_len_ssl + len_;
  
//  if (tlsConnection.connectionState = TLS_CONNECTION_STATE_CONNECTED) then
//    begin
//      Word2Str(len_, debugMsg);
//      UART3_Write_Text(debugMsg);
//    end;
end;

function OpenTCPConnection_SSL(port : word) : boolean;
var i : word;
label end_end_,again_;
begin
  i := 0;

again_:

  Wait_With_Eth(100);

  result := false;
  if Str_Len(flashData.mqttBrokerServer) < 3 then exit;

  if IsIP(flashData.mqttBrokerServer) <> 0 then
    begin
      Str2IP(flashData.mqttBrokerServer, server_addr);
    end
  else
    begin
      if Dns_Resolve(flashData.mqttBrokerServer, server_addr) = false then
        begin
          if Dns_Resolve(flashData.mqttBrokerServer, server_addr) = false then
            begin
              Socket_TCP_buf := 'DNS fail';
              TraceOut(Socket_TCP_buf, Str_Len(Socket_TCP_buf), 1, TRACE_TYPE_ERROR);
              goto end_end_;
            end
          else
            begin
              Socket_TCP_buf := 'DNS resolved';
              TraceOut(Socket_TCP_buf, Str_Len(Socket_TCP_buf), 6, TRACE_TYPE_LOG);
            end;
        end
      else
        begin
          Socket_TCP_buf := 'DNS resolved';
          TraceOut(Socket_TCP_buf, Str_Len(Socket_TCP_buf), 6, TRACE_TYPE_LOG);
          Mem_Cpy(@Socket_TCP_buf, @server_addr, 4);
          TraceOut(Socket_TCP_buf, Str_Len(Socket_TCP_buf), 6, TRACE_TYPE_LOG);
        end;
    end;
  o_sock_ssl := 11;

  Close_TCP_Connection_Advance(o_sock_ssl);   // we use tcp socket 11

  TCP_Close_Port(HTTP_send_Port_ssl);

//  HTTP_send_Port_ssl := HTTP_send_Port_ssl + 1;
//
//  if HTTP_send_Port_ssl > 65000 then
    HTTP_send_Port_ssl := TMR1 + 23456;

  TCP_Open_Port(HTTP_send_Port_ssl);

  if Open_TCP_Connection_Advance(server_addr,port,HTTP_send_Port_ssl,o_sock_ssl) <> 0 then
    begin
      result := true;
      exit;
    end;

end_end_:
  if i < 2 then
    begin
      inc(i);
      goto again_; // try one more time
    end;
end;

// sends message from http_data_out
// encrypts if needed
// return values:
//  0 - No Errors
//  1 - Socket not opened
//  2 - Timeout on send
//  3 - Socket Disconnected
function SendMessage(messageLength: word; waitForResponse: byte) : byte;
var startAddress, stopAddress: word;
    msg: array[32] of char;
    i: word;
begin
  Wait_With_Eth(100);
  result := 0; // no errors
  // check if socket is connected
  if Socket[o_sock_ssl].State_S <> 2 then 
    begin
      tlsConnection.connectionState := TLS_CONNECTION_STATE_CONNECTED;
      msg := 'Socket not opened';
      TraceOut(msg, str_len(msg), 1, TRACE_TYPE_ERROR);
      result := 1;  // Socket not opened
      exit;
    end;

  msg := 'Sending';
  TraceOut(msg, str_len(msg), 1, TRACE_TYPE_LOG);
  TraceOut(HTTP_data_out, messageLength, 3, TRACE_TYPE_LOG);

  // hash outgoing handshake messages, without headers
  if HTTP_data_out[0] = TLS_CONTENT_HANDSHAKE then
    begin
      for i := 5 to messageLength - 1 do
        begin
          AddToHash(HTTP_data_out[i], 0); // SHA-1
          AddToHash(HTTP_data_out[i], 1); // MD5
        end;
    end;
        
  startAddress := @HTTP_data_out;
  stopAddress  := startAddress + messageLength;
  Socket[o_sock_ssl].RAM_ROM         :=    0;
  Socket[o_sock_ssl].Keep_Alive      := true;
  Socket[o_sock_ssl].Exp_Time_Val    := 100;
  Socket[o_sock_ssl].Do_Not_Fragment :=    1;
  Socket[o_sock_ssl].Start_addr      := startAddress;
  Socket[o_sock_ssl].Stop_addr       := stopAddress;

  // Careful here: we are discarding any pending response from host
  host_response := '';
  host_response_len_ssl := 0;
      
  CC0_TCP := 0;
  while Socket[o_sock_ssl].State_S = 2 do      // while connected
    begin
      Do_EthernetProc;
      Process_DHCP;
      if CC0_TCP > 49 then 
        begin
          msg := 'Timeout on send';
          TraceOut(msg, Str_Len(msg), 1, TRACE_TYPE_ERROR);
          result := 2; // Timeout on send
          break; // fail in 4 sec
        end;

      if (waitForResponse <> 0) then
        begin
          if host_response_len_ssl <> 0 then
            begin
              result := 0;
              break;
            end;
        end
      else
        begin
          if Socket[o_sock_ssl].Stop_addr = stopAddress then
            begin
              result := 0;
              break;
            end;
        end;
    end;
      
  Do_EthernetProc;
  // check if socket is connected
  if Socket[o_sock_ssl].State_S <> 2 then
    begin
      tlsConnection.connectionState := TLS_CONNECTION_STATE_CONNECTED;
      msg := 'Socket disconnected';
      TraceOut(msg, str_len(msg), 1, TRACE_TYPE_ERROR);
      result := 3; // Socket disconnected
    end;
end;

// x = 128 bytes
function CreateClientKeyExchange: word; // returns number of bytes
var rsaCipherText: array[128] of byte; // 1024 bits
    i: byte;
    p: ^byte;
    msg: string[32];
begin
      // choose pre master secret
      Random_Array_46(@preMasterSecret.random);
      for i := 0 to 31 do
        begin
          preMasterSecret.random[i] := serverRandom[i] xor TMR1;
        end;
      for i := 32 to 45 do
        begin
          preMasterSecret.random[i] := serverRandom[i - 20] xor TMR1;
        end;
      
      
      {//59E877759
      preMasterSecret.random[0] := 0x59;
      preMasterSecret.random[1] := 0xE8;
      preMasterSecret.random[2] := 0x77;
      preMasterSecret.random[3] := 0x59;}

      // set the TLS version
      preMasterSecret.clientVersion[0] := TLS_VERSION_HIGH;
      preMasterSecret.clientVersion[1] := TLS_VERSION_LO;
      
      {$IFDEF TraceSensitiveInformation}
        msg := 'preMasterSecret random';
        TraceOut(msg, Str_Len(msg), 1, TRACE_TYPE_DEBUG);
        out_broadcast_local(33335,
                            46,
                            preMasterSecret.random);
      {$ENDIF}

      
      // encrypt the premaster secret
      //  1. extend the pre master secret to 1024 bit (128 bytes) integer by adding Random
      //  2. use HTTP_data_out as a temporary storage
      //  3. form the 1024 bit integer (128 bytes) as 00 02 <PS> 00 <Pre Master Secret>
      Random_Array(@HTTP_data_out, 248);
      HTTP_data_out[0]  := $00;  //
      HTTP_data_out[1]  := $02;  // padding identifier, ignore all bytes up to the first 0x00
      HTTP_data_out[79] := 0x00;
      HTTP_data_out[80] := preMasterSecret.clientVersion[0]; // version hi
      HTTP_data_out[81] := preMasterSecret.clientVersion[1]; // version lo
      for i := 0 to 45 do
        begin
           HTTP_data_out[82 + i] := preMasterSecret.random[i];
        end;
      
          begin
            msg := 'public key: exp/base length: ';
            i := Str_Len(msg);
            msg[i]     := Hi(tlsConnection.ServerCertificate.PublicKey.Key.ExponentLength);
            msg[i + 1] := Lo(tlsConnection.ServerCertificate.PublicKey.Key.ExponentLength);
            msg[i + 2] := Hi(tlsConnection.ServerCertificate.PublicKey.Key.ModulusLength);
            msg[i + 3] := Lo(tlsConnection.ServerCertificate.PublicKey.Key.ModulusLength);
            TraceOut(msg, i + 4, 1, TRACE_TYPE_DEBUG);
          end;
      
      // RSA encrypt PreMaster Secret
      i := modexp(rsaCipherText, // Y
             tlsConnection.ServerCertificate.PublicKey.Key.Exponent, // E
             tlsConnection.ServerCertificate.PublicKey.Key.ExponentLength,
             HTTP_data_out,   // PreMasterSsecret   // X or base B
             128,             // PreMasterSecret length with padding
             tlsConnection.ServerCertificate.PublicKey.Key.Modulus, // M
             tlsConnection.ServerCertificate.PublicKey.Key.ModulusLength
             );
             
      if  i <> 0 then
        begin
           msg := 'modexp failed N'; /// N = error code
           msg[14] := i;
           TraceOut(msg, 15, 1, TRACE_TYPE_ERROR);
           result := 0;
           exit;
        end;

      // build a "Client Key Exchange" message
      Mem_Set(@HTTP_data_out, 0, 256);

      // 1. TLS record header
      HTTP_data_out[0] := TLS_CONTENT_HANDSHAKE; // handshake type
      HTTP_data_out[1] := TLS_VERSION_HIGH;
      HTTP_data_out[2] := TLS_VERSION_LO;
      HTTP_data_out[3] := 0x00;
      HTTP_data_out[4] := 0x86;
      
      

      HTTP_data_out[5]  := TLS_HANDSHAKE_CLIENT_KEY_EXCHANGE;     // ClientKeyExchange message type, 0x10
      HTTP_data_out[6]  := $00;     // Message length Higher
      HTTP_data_out[7]  := $00;     // Message length Hi
      HTTP_data_out[8]  := $82;     // Message length Lo - 66 bytes
      
      HTTP_data_out[9]  := $00;
      HTTP_data_out[10] := $80;
      
      // copy rsaCipherText back to HTTP_data_out
       for i := 0 to 127 do
         begin
           HTTP_data_out[11 + i] := rsaCipherText[i];
         end;
      
      result := 139 ;
end;

function CreateClientHello: word; // returns number of bytes
var i: byte;
begin
      // build a "Client Hello" message
      Mem_Set(@HTTP_data_out, 0, 256);

      // 1. TLS record header
      HTTP_data_out[0] := TLS_CONTENT_HANDSHAKE; // handshake type
      HTTP_data_out[1] := TLS_VERSION_HIGH;
      HTTP_data_out[2] := TLS_VERSION_LO;
      HTTP_data_out[3]  := $00;     // content length HiByte
      HTTP_data_out[4]  := $2f;     // content length LoByte => 47B in total after this point

      // 2. Handshake header, hashing starts here
      HTTP_data_out[5]  := TLS_HANDSHAKE_CLIENT_HELLO;     // handshake type code = 1 => clienthello
      HTTP_data_out[6]  := $00;     // length
      HTTP_data_out[7]  := $00;     // length
      HTTP_data_out[8]  := $2b;     // length = 43 bytes from this point onwards

      // 3. client hello starts here
      HTTP_data_out[9]  := TLS_VERSION_HIGH;      // protocol version
      HTTP_data_out[10] := TLS_VERSION_LO;      // protocol version, TLS 1.1

      // client Random
      Random_Array_32(@clientRandom);
      for i := 0 to 31 do
        HTTP_data_out[i + 11] := clientRandom[i]; // from 11 to 42, inclusive

      HTTP_data_out[43] := $00;     // session id byte length, 0 bytes for client hello (no session yet)

      HTTP_data_out[44] := $00;     // ciphersuite list length, hiByte
      HTTP_data_out[45] := $04;     // ciphersuite list length, loByte = 4, i.e. 2 suites

      HTTP_data_out[46] := $00;     // ciphersuite list, suite 1
      HTTP_data_out[47] := $2f;     // ciphersuite list, single ciphersuite TLS_RSA_WITH_AES_128_CBC_SHA

      HTTP_data_out[48] := $00;     // no regotiation supported , suite 2
      HTTP_data_out[49] := $ff;     // no regotiation supported

      HTTP_data_out[50] := $01;     // compression list, compressionmethod 1
      HTTP_data_out[51] := $00;     // compression list, 'null' (no-op) compression
      
      result := 52;
end;

function CreateClientCertificate: word; // returns number of bytes
var i: byte;
begin
{
  This message is only sent if the
      server requests a certificate.  If no suitable certificate is
      available, the client SHOULD send a certificate message containing
      no certificates.  That is, the certificate_list structure has a
      length of zero.
}

    // build a "Client Certificate" message
    Mem_Set(@HTTP_data_out, 0, 256);

    // 1. TLS record header
    HTTP_data_out[0] := TLS_CONTENT_HANDSHAKE; // handshake type
    HTTP_data_out[1] := TLS_VERSION_HIGH;
    HTTP_data_out[2] := TLS_VERSION_LO;
    HTTP_data_out[3] := $00;     // content length HiByte
    HTTP_data_out[4] := $07;     // content length LoByte => 4 B in total after this point

    // 2. Handshake header, hashing starts here
    HTTP_data_out[5] := TLS_HANDSHAKE_CERTIFICATE;
    HTTP_data_out[6] := $00;     // length
    HTTP_data_out[7] := $00;     // length
    HTTP_data_out[8] := $03;     // length = 3 bytes from this point onwards
    HTTP_data_out[9] := $00;     // length
    HTTP_data_out[10] := $00;     // length
    HTTP_data_out[11] := $00;     // length = 0 bytes from this point onwards
 
    // 3. client certificates starts here, if any

    result := 12;
end;


function CreateChangeCipher: word; // returns number of bytes
begin
      // build a "Change Cipher" message
      Mem_Set(@HTTP_data_out, 0, 256);

      // 1. TLS record header
      HTTP_data_out[0]  := TLS_CONTENT_CHANGE_CIPHER;     // content type = change cipher
      HTTP_data_out[1]  := TLS_VERSION_HIGH;
      HTTP_data_out[2]  := TLS_VERSION_LO;

      HTTP_data_out[3]  := $00;     // Message length Hi
      HTTP_data_out[4]  := $01;     // Record length Lo - 1 byte only

      HTTP_data_out[5]  := $01;     // ChangeCipherSpec
      result := 6;
end;

procedure CalculateMasterSecret(var masterSecretOut: array[48] of byte);
var aLabel : string[13];
    seed: array[64] of byte;
    i: byte;
begin
  aLabel := 'master secret';

  // seed = ClientHello.random + ServerHello.random
  for i := 0 to 31 do
    seed[i] := clientRandom[i];

  for i := 0 to 31 do
    seed[i + 32] := serverRandom[i];

  i := PRF(@preMasterSecret,
            48,               // pre master key length
            @aLabel,          // label
            13,               // label length
            @seed,            // ClientHello.random + ServerHello.random
            64,               // seed length
            @masterSecret, // @masterSecretOut, // out masterSecret
            48);              // masterSecret length
            
  if i <> 0 then
    begin
      // PRF Failed
    end;
    
  // it is smart now to delete pre master secret from memory
  for i := 0 to 45 do
    preMasterSecret.random[i] := 0x00;
end;

procedure CalculateKeys(var masterSecretIn: array[48] of byte);
var aLabel : string[13];
    seed: array[64] of byte;
    i: byte;
    keys: array[128] of byte;
begin
  aLabel := 'key expansion';

  // note that server and client Random are in this order now
  // seed = ServerHello.random + ClientHello.random
  for i := 0 to 31 do
    seed[i] := serverRandom[i];
  for i := 0 to 31 do
    seed[i+32] := clientRandom[i];

  i := PRF(@masterSecret, //In,  // note: master secret here
            48,               // master secret length
            @aLabel,          // label
            13,               // label length
            @seed,            // ServerHello.random + ClientHello.random
            64,               // seed length
            @keys,            // out keys
            104);             // PRF length , 20 + 20 + 16 + 16 + 16 + 16 = 104
   
  if i <> 0 then
    begin
      // PRF Failed
    end;
      
  for i := 0 to 19 do
    client_write_MAC_secret[i] := keys[i];
  for i := 20 to 39 do
    server_write_MAC_secret[i-20] := keys[i];
  for i := 40 to 55 do
    client_write_key[i-40] := keys[i];
  for i := 56 to 71 do
    server_write_key[i-56] := keys[i];
  for i := 72 to 87 do
    client_write_IV[i-72]  := keys[i];
  for i := 88 to 103 do
    server_write_IV[i-88]  := keys[i];
end;

function CalculateVerifyData(var verifyDataOut: array[12] of byte): byte;
var seed: array[36] of byte;   //md5 (16 bytes) + sha-1 (20 bytes)
    i: byte;
    aLabel: string[15];
begin
    aLabel := 'client finished';
    // copy MD5
    for i := 0 to 15 do
      begin
        seed[i] := MD5Hash[i];
      end;
    // copy SHA-1
    for i := 0 to 19 do
      begin
        seed[i + 16] := SHA1Hash[i];
      end;

   // compute verify data
   result := Prf (@MasterSecret,
             48,             // Master Secret Length
             @aLabel,        // label
             15,             // label length
             @seed,          // seed
             36,             // seed length
             @verifyDataOut, // verify_data
             12);            // verify_data length
   if i <> 0 then
    begin
      // PRF Failed
    end;
end;

function CalculateServerVerifyData(var verifyDataOut: array[12] of byte): byte;
var seed: array[36] of byte;   //md5 (16 bytes) + sha-1 (20 bytes)
    i: byte;
    aLabel: string[15];
begin
  aLabel := 'server finished';
  // copy MD5
  for i := 0 to 15 do
    begin
      seed[i] := MD5Hash[i];
    end;
  // copy SHA-1
  for i := 0 to 19 do
    begin
      seed[i + 16] := SHA1Hash[i];
    end;

 // compute verify data
  result := Prf (@MasterSecret,
           48,             // Master Secret Length
           @aLabel,        // label
           15,             // label length
           @seed,          // seed
           36,             // seed length
           @verifyDataOut, // verify_data
           12);            // verify_data length
 if result <> 0 then
  begin
    // PRF Failed
  end;
end;

function CreateClientFinished(): word; // returns number of bytes
var i: byte;
    verifyData: array[12] of byte;
    messageHMAC: array[20] of byte;
    toEncrypt: array[48] of byte;
    dataInFinal: array[64] of byte;
begin
   // prepare data
      //compute the final hashes
      for i := 0 to tlsConnection.toHashMD5.dataLength - 1 do
        dataInFinal[i] := tlsConnection.toHashMD5.dataIn[i];
        
      MD5SHAFinal( @dataInFinal,  @MD5Hash,  tlsConnection.toHashMD5.dataLength,  1, 2);
      
      for i := 0 to tlsConnection.toHashSHA1.dataLength - 1 do
        dataInFinal[i] := tlsConnection.toHashSHA1.dataIn[i];
        
      MD5SHAFinal( @dataInFinal, @SHA1Hash, tlsConnection.toHashSHA1.dataLength, 0, 1);
   
      // compute master secret
      CalculateMasterSecret(masterSecret);
      CalculateKeys(masterSecret);
     
      // compute verify data
      CalculateVerifyData(verifyData); // todo: check result
      // build a "client finished" message
      // the Plan:
      //   1. calculate HMAC on associated data + verify data
      //   2. Pad HMAC and verify data
      //   3. CBC encrypt padded message using client IV
      //   4. pack the message
      
      // 1. calculate HMAC on associated data + verify data
      Mem_Set(@toEncrypt, 0, 48);
      // associated data // current sequence number, 8 x 0x00
      for i := 0 to 7 do
        toEncrypt[i] := 0;
      
      // 1. TLS record header
      toEncrypt[8]  := TLS_CONTENT_HANDSHAKE;     // content type = handshake, 0x16
      toEncrypt[9]  := TLS_VERSION_HIGH;
      toEncrypt[10] := TLS_VERSION_LO;
      toEncrypt[11] := $00;     // Message length Hi
      toEncrypt[12] := $10;     // Record  length Lo - 16 bytes
      
      // add TLS handshake header 14 00 00 0C
      toEncrypt[13] := TLS_HANDSHAKE_FINISHED;
      toEncrypt[14] := 0x00;
      toEncrypt[15] := 0x00;
      toEncrypt[16] := 0x0C;

      // append verify data
      for i := 0 to 11 do
        begin
           toEncrypt[17 + i] := verifyData[i];
        end;
        
      // calculate HMAC SHA-1 of the message
      HMAC_ShaMd5(@client_write_MAC_secret,  // Secret
                  20,             // Secret length
                  @toEncrypt,     // Data to hash
                  29           ,  // Data length
                  @messageHMAC ,  // Hash result
                  0);             // SHA-1
                  
      //2. concat verify data and HMAC
      Mem_Set(@toEncrypt, 0, 48);
      // add TLS handshake header 14 00 00 0C
      toEncrypt[0] := TLS_HANDSHAKE_FINISHED;
      toEncrypt[1] := 0x00;
      toEncrypt[2] := 0x00;
      toEncrypt[3] := 0x0C;
      
      // copy verify data
      for i := 0 to 11 do
        toEncrypt[4 + i] := verifyData[i];

      // copy HMAC
      for i := 0 to 19 do
        toEncrypt[16 + i] := messageHMAC[i];

      // pad with 0x0B to the first multiple of 16 which is 48
      for i := 36 to 47 do
        toEncrypt[i] := 0x0B;
        
      //3. CBC encrypt
      AES_128_CBC_encrypt(@client_write_key, @client_write_IV, @toEncrypt, 48);
      
      // 4. pack the message
      HTTP_data_out[0] := TLS_CONTENT_HANDSHAKE;     // content type = handshake, 0x16
      HTTP_data_out[1] := TLS_VERSION_HIGH;
      HTTP_data_out[2] := TLS_VERSION_LO;
      HTTP_data_out[3] := $00;     // Message length Hi
      HTTP_data_out[4] := $40;     // Record  length Lo - 64 bytes
      
      // append client IV
      for i := 0 to 15 do
        HTTP_data_out[5 + i] := client_write_IV[i];

      for i := 0 to 47 do
        HTTP_data_out[21 + i] := toEncrypt[i];

      result := 69;
end;

function ProcessServerHello(var startIndex: word): byte;
var serverHelloLength: dword;
    stopIndex, locali: word;
    counter: dword;
    serverHelloVersion: array[2] of byte;
    sessionID: array[32] of byte; // careful here, the length can be longer
    sessionIDLength: byte;
    extensionsLength: word;
    debugMsg: string[32];
begin
  result := 2; // server hello expected
  serverCertificateStartIndex := 0;
 
  sessionIDLength := 0;
  Mem_Set(@ServerRandom, 0, 32);
  
   if     (host_response[startIndex] = TLS_CONTENT_HANDSHAKE) // this is a TLS response
      and (host_response[startIndex + 1] = TLS_VERSION_HIGH) // TLS 1.1
      and (host_response[startIndex + 2] = TLS_VERSION_LO) // TLS 1.1
      and (host_response[startIndex + 5] = TLS_HANDSHAKE_SERVER_HELLO)
      then
     begin
       startIndex := startIndex + 5; // start from server hello

       serverHelloLength := 0;
       Higher(serverHelloLength) := host_response[startIndex + 1];
       Hi(serverHelloLength) := host_response[startIndex + 2];
       lo(serverHelloLength) := host_response[startIndex + 3];

       serverHelloLength := serverHelloLength + 4; // include server hello id, plus 3 bytes for length
       stopIndex  := startIndex + serverHelloLength - 1;

//       uart3_write_text(' /hashing from ');
//       Word2str(startIndex * 2, debugMsg);
//       uart3_write_text(debugMsg);
//
//       uart3_write_text(' to ');
//       Word2str(stopIndex * 2, debugMsg);
//       uart3_write_text(debugMsg);
//
//       uart3_write_text('/ ');

       counter    := 0;
       for locali := startIndex to stopIndex do
         begin
           ClrWDT();
           // hash the entire message, without headers
           AddToHash(host_response[locali], 0); // SHA-1
           AddToHash(host_response[locali], 1); // MD5

           // server hello version
           if counter = 4 then
             serverHelloVersion[0] := host_response[locali]
           else if counter = 5 then
             serverHelloVersion[1] := host_response[locali];

           //compare server TLS version with what we want (prevent downgrade attack)
           if counter >= 5 then
             begin
               if (serverHelloVersion[0] <> TLS_VERSION_HIGH) or
                  (serverHelloVersion[1] <> TLS_VERSION_LO) then
               begin
                 result := 11; // invalid TLS version from server
                 exit;
               end;
             end;
             
           //extract server random
           if (counter >= 6) and (counter <= 37) then // server Random
             begin
               ServerRandom[counter - 6] := host_response[locali];

               if counter = 37 then
                 begin
                    debugMsg := 'Server Random';
                    TraceOut(debugMsg, Str_Len(debugMsg), 6, TRACE_TYPE_LOG);
                    TraceOut(serverRandom, 32, 6, TRACE_TYPE_LOG);
                 end;
             end;
            
            // extract session id
           if counter = 38 then
             sessionIDLength := host_response[locali];

           if     (counter >= 39)
              and (counter <= 39 + sessionIDLength - 1)
              and (sessionIDLength <= 32)  then
             begin
               sessionID[counter - 39] := host_response[locali];
             end;

           // extract ciphercuite value
            // take two bytes of server's ciphesuite value
           if (counter =  39 + sessionIDLength) then
             tlsConnection.serverCipherSuite[0] := host_response[locali];
           if (counter =  39 + sessionIDLength + 1) then
             tlsConnection.serverCipherSuite[1] := host_response[locali];

           // server compression method
           if (counter =  39 + sessionIDLength + 2) then
            begin
              tlsConnection.serverCompressionMethod := host_response[locali];

                begin
                  debugMsg := 'sessionID';
                  TraceOut(debugMsg, Str_Len(debugMsg), 6, TRACE_TYPE_LOG);
                  TraceOut(sessionID, sessionIDLength, 6, TRACE_TYPE_LOG);

                  debugMsg := 'serverCipherSuite';
                  TraceOut(debugMsg, Str_Len(debugMsg), 6, TRACE_TYPE_LOG);
                  TraceOut(tlsConnection.serverCipherSuite, 2, 6, TRACE_TYPE_LOG);

                  debugMsg := 'serverCompressionMethod N';
                  debugMsg[Str_Len(debugMsg) - 1] := tlsConnection.serverCompressionMethod + 48;
                  TraceOut(debugMsg, Str_Len(debugMsg), 6, TRACE_TYPE_LOG);
                end;
            end;

           if (counter =  39 + sessionIDLength + 2 + 1) then
             Hi(extensionsLength) := host_response[locali];
           if (counter =  39 + sessionIDLength + 2 + 2) then
             Lo(extensionsLength) := host_response[locali];

           if    (counter >=  39 + sessionIDLength + 2 + 3)
             and (counter <=  39 + sessionIDLength + 2 + 3 + extensionsLength - 1)
           then
             begin
               // todo: skiping server extensions
             end;

           inc(counter);
           dec(serverHelloLength);
           
           // done with server hello; server certificate starts
           if serverHelloLength = 0 then
             begin
               serverCertificateStartIndex := locali + 1;
               result := 0;
               exit;
             end;
         end;
     end;
end;

function ProcessServerCertificate(var startIndex: word): byte;
var debugMsg: string[32];
    serverCertificateLength: dword;
    parsedBytes : word;
    locali, stopIndex: word;
begin
  result := 3; // server certificate expected

  tlsConnection.ServerCertificate.PublicKey.Key.Exponent[0] := 0;
  tlsConnection.ServerCertificate.PublicKey.Key.Exponent[1] := 0;
  tlsConnection.ServerCertificate.PublicKey.Key.Exponent[2] := 0;
  tlsConnection.ServerCertificate.PublicKey.Key.Exponent[3] := 0;
  tlsConnection.ServerCertificate.PublicKey.Key.ModulusLength  := 0;
  tlsConnection.ServerCertificate.PublicKey.Key.ExponentLength := 0;
  for locali := 0 to 511 do
    tlsConnection.ServerCertificate.PublicKey.Key.Modulus[locali] := 0;

  locali := startIndex;
  // server can send the header again
  if    (host_response[locali] = TLS_CONTENT_HANDSHAKE)
    and (host_response[locali + 1] = TLS_VERSION_HIGH)
    and (host_response[locali + 2] = TLS_VERSION_LO)
   then
    begin
      locali := locali + 5; // skip header
//      uart3_write_text(' skipping header ');
    end
  else
    begin
//      uart3_write_text(' no header ');
    end;

  if (host_response[locali] = TLS_HANDSHAKE_CERTIFICATE) then // server certificate 0x0b
    begin
      serverCertificateLength := 0;
      Higher(serverCertificateLength) := host_response[locali + 1];
      Hi(serverCertificateLength) := host_response[locali + 2];
      Lo(serverCertificateLength) := host_response[locali + 3];

//      uart3_write_text(' serverCertificateLength ');
//      Word2Hex(serverCertificateLength, debugMsg);
//      uart3_write_text(debugMsg);
      

      serverCertificateLength := serverCertificateLength + 4; // certificate id + 3 bytes for length
      
      // extract certificates
      startIndex := locali;
      stopIndex  := startIndex + word(serverCertificateLength) - 1;

//       uart3_write_text(' /hashing from ');
//       Word2str(startIndex * 2, debugMsg);
//       uart3_write_text(debugMsg);

//       uart3_write_text(' to ');
//       Word2str(stopIndex * 2, debugMsg);
//       uart3_write_text(debugMsg);
//
//       uart3_write_text('/ ');

      for locali := startIndex to stopIndex do
        begin
          // todo: keep the certificate somewhere, then compare it with trusted, for security
          AddToHash(host_response[locali], 0); // SHA-1
          AddToHash(host_response[locali], 1); // MD5
        end;
//      uart3_write_text(' hashing done at: ');
//      byte2Hex(stopIndex, debugMsg);
//      uart3_write_text(debugMsg);


      //** todo: pull this block out of this function
      if    (host_response[stopIndex + 1] = TLS_CONTENT_HANDSHAKE)
        and (host_response[stopIndex + 2] = TLS_VERSION_HIGH)
        and (host_response[stopIndex + 3] = TLS_VERSION_LO)
        and (host_response[stopIndex + 6] = TLS_HANDSHAKE_CERTIFICATE_REQUEST)
       then
        begin
          certificateRequestIndex := stopIndex + 1;
        end
      else if    (host_response[stopIndex + 1] = TLS_HANDSHAKE_CERTIFICATE_REQUEST) then
        begin
          certificateRequestIndex := stopIndex + 1;
        end;

      if    (host_response[stopIndex + 1] = TLS_CONTENT_HANDSHAKE)
        and (host_response[stopIndex + 2] = TLS_VERSION_HIGH)
        and (host_response[stopIndex + 3] = TLS_VERSION_LO)
        and (host_response[stopIndex + 6] = TLS_HANDSHAKE_SERVER_HELLO_DONE)
       then
        begin
          helloDoneStartIndex := stopIndex + 1;
        end
      else if    (host_response[stopIndex + 1] = TLS_HANDSHAKE_SERVER_HELLO_DONE) then
        begin
          helloDoneStartIndex := stopIndex + 1;
        end;
      //~

      // move to the first cert. assuming it starts with 0x3082
      locali := startIndex;
//      while ((host_response[locali] <> 0x30) and
//             (host_response[locali + 1] <> 0x82)) do
      while true do
        begin
          if ((host_response[locali] = 0x30) and
              (host_response[locali + 1] = 0x82)) then
            begin
              break;
            end;
          inc(locali);
          if locali >= serverCertificateLength then
            begin
//              uart3_write_text(' emergency out ');
              break;
            end;
        end;
      startIndex := locali;
      
//      uart3_write_text(' start cert at ');
//      Word2Hex(startIndex, debugMsg);
//      uart3_write_text(debugMsg);
      
//      uart3_write_text(' serverCertificateLength ');
//      Word2Hex(serverCertificateLength, debugMsg);
//      uart3_write_text(debugMsg);

      X509Init(host_response, serverCertificateLength);
      if startIndex < serverCertificateLength then
        begin
          while (word(startIndex) < word(serverCertificateLength)) do
            begin
              parsedBytes := DecodeCertificate(host_response, tlsConnection.ServerCertificate, startIndex);
              if parsedBytes = 0 then
                begin
                  break;
                end;
              startindex := startindex + parsedBytes;
              if tlsConnection.ServerCertificate.PublicKey.Key.ModulusLength > 0 then // we have the key
                begin
                  if tlsConnection.ServerCertificate.PublicKey.Key.ExponentLength > 0 then // we have the key
                    break;
                end;
            end;
              
          if (tlsConnection.ServerCertificate.PublicKey.Key.ModulusLength = 0) or
             (tlsConnection.ServerCertificate.PublicKey.Key.ExponentLength = 0) then
            begin
              debugMsg := 'Server public key not found';
              TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
              result := 8;
              exit;
            end
          else
            begin
              debugMsg := 'Server public key and exp:';
              TraceOut(debugMsg, Str_Len(debugMsg), 6, TRACE_TYPE_LOG);
              TraceOut(tlsConnection.serverCertificate.PublicKey.Key.Modulus,
                       tlsConnection.serverCertificate.PublicKey.Key.ModulusLength,
                       6, TRACE_TYPE_LOG);
              TraceOut(tlsConnection.serverCertificate.PublicKey.Key.Exponent,
                       tlsConnection.serverCertificate.PublicKey.Key.ExponentLength,
                       6, TRACE_TYPE_LOG);
              result := 0
            end;
        end
      else
        begin
          debugMsg := 'invalid server cert. length';
          TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
          result := 9;
        end;
    end
  else
    begin
      debugMsg := 'expected server cert.';
      TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
      result := 10;
    end;

  if (result = 0) then
    begin
       if (tlsConnection.ServerCertificate.PublicKey.Key.ModulusLength <> 128) then
         begin
           result := 12; // invalid public key modulus
           
           debugMsg := 'Invalid public key modulus';
           TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);

           debugMsg[0] := Hi(tlsConnection.ServerCertificate.PublicKey.Key.ModulusLength);
           debugMsg[1] := Lo(tlsConnection.ServerCertificate.PublicKey.Key.ModulusLength);
           out_broadcast_local(33335, 2, debugMsg);
         end;
    end;
end;

function ProcessServerCertificateRequest(): byte;
var requestLength: dword;
    locali, startIndex, stopIndex: word;
    debugMsg: string[32];
begin
  result := 15; // invalid request
  
//  uart3_write_text(' certificateRequestIndex ');
//  Word2Hex(certificateRequestIndex, debugMsg);
//  uart3_write_text(debugMsg);
  
 // server can send the header again
  if    (host_response[certificateRequestIndex] = TLS_CONTENT_HANDSHAKE)
    and (host_response[certificateRequestIndex + 1] = TLS_VERSION_HIGH)
    and (host_response[certificateRequestIndex + 2] = TLS_VERSION_LO)
   then
    begin
      certificateRequestIndex := certificateRequestIndex + 5; // skip header
    end
  else
    begin
    end;
  
  if (host_response[certificateRequestIndex] <> TLS_HANDSHAKE_CERTIFICATE_REQUEST) then
    exit;

  higher(requestLength) := host_response[certificateRequestIndex + 1];
      hi(requestLength) := host_response[certificateRequestIndex + 2];
      lo(requestLength) := host_response[certificateRequestIndex + 3];

//  uart3_write_text(' certificateRequestStartIndex: ');
//  Word2Hex(certificateRequestIndex, debugMsg);
//  uart3_write_text(debugMsg);

  startIndex := certificateRequestIndex;
  stopIndex  := startindex + requestLength + 4 - 1; // todo: check out of 16bit bounds
  
//  uart3_write_text(' certificateRequeststopIndex: ');
//  Word2Hex(stopIndex, debugMsg);
//  uart3_write_text(debugMsg);

//  uart3_write_text(' /hashing from ');
//  Word2str(startIndex * 2, debugMsg);
//  uart3_write_text(debugMsg);

//  uart3_write_text(' to ');
//  Word2str(stopIndex * 2, debugMsg);
//  uart3_write_text(debugMsg);
//
//  uart3_write_text('/ ');
  
  for locali := startIndex to stopIndex do
    begin
      // hash
      AddToHash(host_response[locali], 0); // SHA-1
      AddToHash(host_response[locali], 1); // MD5
    end;

  // here we expect hello done, let's check
  if (helloDoneStartIndex <> stopIndex + 1) then
    begin
      // todo: throw error/warning
//      UART3_Write_Text(' W: changing hello done ');
//      Word2Hex(helloDoneStartIndex, debugMsg);
//      uart3_write_text(debugMsg);
      
      helloDoneStartIndex := stopIndex + 1;
      
//      Word2Hex(helloDoneStartIndex, debugMsg);
//      uart3_write_text(debugMsg);
    end;
  result := 0;
end;

function ProcessServerHelloDone(): byte;
var locali, startindex, stopindex: word;
    debugMsg: array[32] of char;
begin
  result := 4; // server hello done expected

  if helloDoneStartIndex = 0 then
    exit;
   
//  uart3_write_text(' helloDoneStartIndex: ');
//  Word2Hex(helloDoneStartIndex, debugMsg);
//  uart3_write_text(debugMsg);
    
  // check if header exists
  if    (host_response[helloDoneStartIndex] = TLS_CONTENT_HANDSHAKE)
    and (host_response[helloDoneStartIndex + 1] = TLS_VERSION_HIGH)
    and (host_response[helloDoneStartIndex + 2] = TLS_VERSION_LO)
  then
    begin
      helloDoneStartIndex := helloDoneStartIndex + 5;
    end
  else
    begin
    end;

  if (host_response[helloDoneStartIndex] = TLS_HANDSHAKE_SERVER_HELLO_DONE) then // server hello done 0x0e
    begin
      startIndex := helloDoneStartIndex;
      stopIndex  := helloDoneStartIndex + 4 - 1; // 4 bytes in hello done
      
//       uart3_write_text(' /hashing from ');
//       Word2str(startIndex * 2, debugMsg);
//       uart3_write_text(debugMsg);
//
//       uart3_write_text(' to ');
//       Word2str(stopIndex * 2, debugMsg);
//       uart3_write_text(debugMsg);
//
//       uart3_write_text('/ ');
      
      for locali := startIndex to stopIndex do
         begin
           // hash
           AddToHash(host_response[locali], 0); // SHA-1
           AddToHash(host_response[locali], 1); // MD5
         end;

      result := 0;
    end
  else
    begin
      debugMsg := 'expected Server hello done';
      TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
      debugMsg[0] := host_response[helloDoneStartIndex - 1];
      debugMsg[1] := host_response[helloDoneStartIndex + 0];
      debugMsg[2] := host_response[helloDoneStartIndex + 1];
      debugMsg[3] := host_response[helloDoneStartIndex + 2];
      debugMsg[4] := host_response[helloDoneStartIndex + 3];
      TraceOut(debugMsg, 5, 1, TRACE_TYPE_ERROR);
    end;
end;

function ProcessServerChangeCipher(var startIndex: word): byte;
var debugMsg: array[32] of char;
begin
  result := 13; // server change cipher expected

  // check if header exists
  if    (host_response[startIndex] = TLS_CONTENT_CHANGE_CIPHER)
    and (host_response[startIndex + 1] = TLS_VERSION_HIGH)
    and (host_response[startIndex + 2] = TLS_VERSION_LO)
  then
    begin
      startIndex := startIndex + 3;
    end
  else
    begin
      exit;
    end;

  if (host_response[startIndex] <> 0x00) then
    exit;

  inc(startIndex);
  if (host_response[startIndex] <> 0x01) then
    exit;

  inc(startIndex);
  if (host_response[startIndex] <> 0x01) then
    exit;

  result := 0;
end;

function ProcessServerFinished(startIndex: word): byte;
var locali, stopindex: word;
    debugMsg: array[32] of char;
    msgLength: word;
    i: byte;
    finishedMessage: array[64] of byte;
    serverVerifyData: array[12] of byte;
begin
  result := 14; // server finished expected

  msgLength := 0;
  // check if header exists
  if    (host_response[startIndex] = TLS_CONTENT_HANDSHAKE)
    and (host_response[startIndex + 1] = TLS_VERSION_HIGH)
    and (host_response[startIndex + 2] = TLS_VERSION_LO)
  then
    begin
      hi(msgLength) := host_response[startIndex + 3];
      lo(msgLength) := host_response[startIndex + 4];

      if (msgLength > 64) then //todo: check if this is a limitation
        exit; 
      
      startIndex := startIndex +  5;
      stopindex  := startIndex + 64;
    end
  else
    begin
      debugMsg := 'expected Server Finished';
      TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
      exit;
    end;

  for locali := startIndex to stopIndex - 1 do
     begin
       finishedMessage[locali - startIndex] := host_response[locali];
     end;

  result := CalculateServerVerifyData(serverVerifyData);
  if (result <> 0) then
    begin
      result := 16;  // failed to calculate server finished
      debugMsg := 'Failed server verify';
      TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_LOG);
    end
  else
    begin
      AES_128_CBC_decrypt(@server_write_key, @server_write_IV, @finishedMessage, 64);
      debugMsg := 'decrypted Server Finished';
      TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_LOG);
      TraceOut(finishedMessage, 64, 6, TRACE_TYPE_DEBUG);
      TraceOut(serverVerifyData, 12, 6, TRACE_TYPE_DEBUG);
      result := 0;
    end;
end;

procedure SendAlertMessage(alertType: byte);
begin
 // todo: this must be encrypted, move to TLSSend()
  HTTP_data_out[0] := TLS_CONTENT_ALERT; // handshake type
  HTTP_data_out[1] := TLS_VERSION_HIGH;
  HTTP_data_out[2] := TLS_VERSION_LO;
  HTTP_data_out[3] := 0x00;
  HTTP_data_out[4] := 0x02; // length always 2
  HTTP_data_out[5] := 0x02; // alert level, 01 - warning, 02 - fatal
  HTTP_data_out[6] := alertType;  // alert description

  SendMessage(7, false);
end;

//** error codes:
//  0 - no error
//  1 - Port not opened
//  2 - Server hello expected
//  3 - Server certificate expected
//  4 - Server hello done expected
//  5 - Client Key Exchange not sent
//  6 - Client ChangeCipher not sent
//  7 - Client Finished not sent
//  8 - Server's public key not detected
//  9 - Invalid server certificate length
// 10 - Expected server certificate
// 11 - Invalid TLS version from server
// 12 - Invalid public key modulus
// 13 - Expected server Change Cipher
// 14 - Expected server Finished
// 15 - Invalid server certificate request
// 16 - Client Certificate not sent
function Open_SSL(port : word) : boolean;
var
    serverResponseLength: word;
    locali: word;
    startIndex, stopIndex: word;
    ptr: ^byte;
    messageLength: word;
    debugMsg: string[32];
    res: byte;
    sendCertificate: byte;
begin
  result := 1;
  tlsConnection.connectionState := TLS_CONNECTION_STATE_DISCONNECTED;
  Random_Init();
  ClearSequenceNumber();
  if OpenTCPConnection_SSL(port) <> 0 then
    begin
      tlsConnection.connectionState := TLS_CONNECTION_STATE_HANDSHAKING;
      tlsConnection.toHashMD5.firstBlock := TRUE; // start a new hash
      tlsConnection.toHashMD5.dataLength := 0;
      
      tlsConnection.toHashSHA1.firstBlock := TRUE; // start a new hash
      tlsConnection.toHashSHA1.dataLength := 0;
      
      messageLength := CreateClientHello();
      if (SendMessage(messageLength, TRUE) = 0) then
        begin
          Wait_With_Eth(500);
          TraceOut(host_response, host_response_len_ssl, 1, TRACE_TYPE_DEBUG);
          
          // **  server response consists of three parts:
          //    1. Server hello
          //    2. Server certificate
          //    3. Server hello done

          serverCertificateStartIndex := 0;
          helloDoneStartIndex         := 0;
          certificateRequestIndex     := 0;

          // 1. Server hello
            begin
              locali := 0;
              result := ProcessServerHello(locali);
            end;

//          UART3_Write_Text(' Starting cert ');
          
          // 2. Server certificate
          if result = 0 then
            begin
              result := ProcessServerCertificate(serverCertificateStartIndex);
            end;

//          UART3_Write_Text(' Ended cert ');

         // 2a. If exists, ServerCertificateRequest
         if (result = 0) then
            begin
              if (certificateRequestIndex > 0) then
                begin
                  result := ProcessServerCertificateRequest();
                end;
            end;

         // 3. Server hello done
          if result = 0 then
            begin
              result := ProcessServerHelloDone();
            end;
            
            
         // 4. if server requested certificate, now it should be sent
         if (certificateRequestIndex <> 0) then
            begin
              messageLength := CreateClientCertificate();
              res := SendMessage(messageLength, false);
              if (res = 0) then
                begin
                  debugMsg := '"Client Certificate" Sent';
                  TraceOut(debugMsg, Str_Len(debugMsg), 6, TRACE_TYPE_LOG);
                  result := 0;
                end
              else
                begin
                  result   := 16; // client Certificate not sent
                  debugMsg := '"Client Certificate" NOT Sent';
                  TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
                end;
            end;
            
          Wait_With_Eth(500);
          if result = 0 then
            begin
              // prepare Client Key Exchange message
              messageLength := CreateClientKeyExchange();
              res := SendMessage(messageLength, false);
              
              if (res = 0) then
                begin
                  debugMsg := '"Client Key Exchange" Sent';
                  TraceOut(debugMsg, Str_Len(debugMsg), 6, TRACE_TYPE_LOG);
                end
              else
                begin
                  debugMsg := '"Client Key Exchange" NOT Sent';
                  TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
                end;
              
              Wait_With_Eth(1500);
              if (res = 0) then
                begin
                  host_response_len_ssl := 0;
                  messageLength := CreateChangeCipher();
                  res := SendMessage(messageLength, false);
                  Wait_With_Eth(500);
                  if (res = 0) then
                    begin
                      debugMsg := '"Change Cipher" Sent';
                      ClearSequenceNumber();
                      TraceOut(debugMsg, Str_Len(debugMsg), 6, TRACE_TYPE_LOG);

                      messageLength := CreateClientFinished();
                      res := SendMessage(messageLength, true);
                      if (res = 0) then
                        begin
                          IncrementSequenceNumber();
                          for res := 0 to 15 do
                            begin
                              client_write_IV[res] := HTTP_data_out[messageLength - 16];
                            end;
                          
                          debugMsg := '"Client Finished" Sent';
                          TraceOut(debugMsg, Str_Len(debugMsg), 6, TRACE_TYPE_LOG);
                        end
                      else
                        begin
                          result   := 7; // client Finished not sent
                          debugMsg := '"Client Finished" NOT Sent';
                          TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
                        end;
                    end
                  else
                    begin
                      result   := 6; // client ChangeCipher not sent
                      debugMsg := '"Change Cipher" NOT Sent';
                      TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
                    end;
                   
                  // expected server's "Change Cipher"
                  if (result = 0) then
                    begin
                      TraceOut(host_response, host_response_len_ssl, 1, TRACE_TYPE_DEBUG);
                      locali := 0;
                      result := ProcessServerChangeCipher(locali);
                      // locali now points to end of change cipher
                      locali := locali + 1; // move to finished, if any
                    end;

                  // expected server's "Finished"
                  if (result = 0) then
                    begin
                      Wait_With_Eth(500);
                      debugMsg := 'Expecting "Finished"';
                      TraceOut(debugMsg, Str_Len(debugMsg), 6, TRACE_TYPE_LOG);
                      result := ProcessServerFinished(locali);
                      if result <> 0 then // try to get it again
                        begin
                          host_response_len_ssl := 0; // expect a new message
                          Eth_ProcessTCP(); // take server msg if any
                          TraceOut(host_response, host_response_len_ssl, 1, TRACE_TYPE_DEBUG);
                          locali := 0;
                          result := ProcessServerFinished(locali);
                        end;
                    end;
                end
              else
                begin
                  result := 5; // clientkey exchange not sent
                  debugMsg := '"Client Key Exchange" NOT Sent';
                  TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
                end;
            end;
         end;
      if (result <> 0) then
        begin
          tlsConnection.connectionState := TLS_CONNECTION_STATE_DISCONNECTED;
          debugMsg := 'Handshake ended with errors';
          TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
          //todo: send alert message?
          //SendAlertMessage(TLS_ALERT_HANDSHAKE_FAILURE);
        end
      else
        begin
          tlsConnection.connectionState := TLS_CONNECTION_STATE_CONNECTED;
          debugMsg := 'Handshake completed successfully';
          TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_LOG);
        end;
    end;
end;

// hashOutLength is of max size of 255
// Return values:
//  0 - no error
//  1 - seed too long, max 128
//  2 - hashSize + seedLength is too long, max 255
function P_Hash
             (secretKey: ^byte; secretKeyLength: word;
              seed     : ^byte; seedLength: word;
              hashOut  : ^byte; hashOutLength: word;
              sha1Md5  : byte): byte;
var i: byte;
    aHash, hHash: array[20] of byte;
    aAndSeed: array[255] of byte;
    hashSize: byte;
    msg: string[5];
    seedArray: array[128] of byte;
begin
  result := 0;
  
  if sha1Md5 = 0 then
    hashSize := 20
  else
    hashSize := 16;
  
  if (seedLength > 128) then
    begin
      result := 1;
      exit;
    end;
    
  if (word(hashSize + seedLength) > 255) then
    begin
      result := 2;
      exit;
    end;
  
  for i := 0 to seedLength - 1 do
    begin
      seedArray[i] := seed^;
      inc(seed);
    end;
      


  // A0 = seed
  // A1 = hmac(secret, seed) = hmac(secret, A0)
  // P_Hash1 = hmac(secret, A1 + seed);

  // A2 = hmac(secret, A1)
  // P_Hash2 = hmac(secret, A2 + seed);
  
  // A1
  HMAC_ShaMd5(secretKey, secretKeyLength,
              @seedArray, seedLength,
              @aHash, // this is A1
              sha1Md5);
  // build A1 + seed
  for i := 0 to hashSize - 1 do
    aAndSeed[i] := aHash[i];
  for i := 0 to seedLength - 1 do
    begin
      aAndSeed[i + hashSize] := seedArray[i];
    end;

  while hashOutLength > 0 do
    begin
      // calculate PHash = hmac(secret, A + seed)
      HMAC_ShaMd5(secretKey, secretKeyLength,
                  @aAndSeed, hashSize + seedLength,
                  @hHash,   // this is P_Hash
                  sha1Md5);
      for i := 0 to hashSize - 1 do
        begin
          hashOut^ := hHash[i];
          inc(hashOut);
          dec(hashOutLength);
          if hashOutLength = 0 then
            break;
        end;
      // Set A for next iteration
      // A(i) = HMAC_hash( secret, A(i-1) )
      HMAC_ShaMd5(secretKey, secretKeyLength,
                  @aHash, hashSize,
                  @hHash,
                  sha1Md5);
      for i := 0 to hashSize - 1 do
        begin
          aAndSeed[i] := hHash[i];
          aHash[i]    := hHash[i];
        end;
      // this loop might not be needed, but leave it for learning purposes
      for i := 0 to seedLength - 1 do
        begin
          aAndSeed[i + hashSize] := seedArray[i];
        end;
    end;
end;

// - labelLength does not include a trailing zero
// - prfLength is of max size of 255
// - Return values:
//    0 - no errors
//    1 - prfLength too long
//    2 - labelLength + seedLength is too long (max 255)
//    3 - P_Hash() error
function PRF(secretKey: ^byte; secretKeyLength: word;
              aLabel   : ^byte; labelLength: word;
              seed     : ^byte; seedLength: word;
              PRFOut   : ^byte; prfLength: word): byte;
var halfSecretLength: word;
    sha1Out: array[255] of byte;
    i : byte;
    msg : string[5];
    concat: string[255];
    res : byte;
begin
  result := 0; // no errors
  
  if (prfLength > 255) then
    begin
      result := 1; // prfLength too long
      exit;
    end;
    
  if (word(labelLength + seedLength) > 255) then
    begin
      result := 2; // labelLength + seedLength too long
      exit;
    end;
  
  halfSecretLength := (secretKeyLength div 2) + (secretKeyLength mod 2);
  
  for i := 0 to labelLength - 1 do
    begin
      concat[i] := aLabel^;
      inc(aLabel);
    end;
  for i := 0 to  seedLength- 1 do
    begin
      concat[i + labelLength] := seed^;
      inc(seed);
    end;
  
  res := P_Hash(secretKey, halfSecretLength,
         @concat, labelLength + seedLength,
         PRFOut, prfLength, 
         1); // md5

  if res <> 0 then // indicate error, but proceed with random values
    result := 3;   //  to protect from timing attack
         
  res := P_Hash(secretKey + (secretKeyLength div 2), halfSecretLength,
         @concat, labelLength + seedLength,
         @sha1Out, prfLength, 
         0); // sha-1
  if res <> 0 then  // indicate error, but proceed with random values
    result := 3;    //  to protect from timing attack
         
  for i := 0 to prfLength - 1 do
    begin
      PRFOut^ := PRFOut^ xor sha1Out[i];
      inc(PRFOut);
    end;
end;

//todo: refactor TLSSend. It is already used in ClientFinished
// return values:
//   0 - No Errors
//   1 - Socket not opened
//   2 - Timeout on send
//   3 - Socket Disconnected
//   4 - Data too long
// 101 - Encryption failed
function TLSSendInternal(var outData: array[128] of byte; dataLength: byte): byte;
var i, limit, paddingByte: byte;
    messageHMAC: array[20] of byte;
    toEncrypt: array[254] of byte;
    debugMsg: string[32];
    messageLength: word;
{
  Sequence number is never transmitted, encrypted or otherwise;
  its just prepended to the MAC buffer before the packet is MACed. Therefore,
  given a content buffer of content, the buffer that is MACed looks like this:
 
  buffer = <SeqNumber:8><MessageType:1><Version:2><ContentLength:2><Content:Variable>
  
  Digest is calculated over the buffer
  digest = MAC(buffer) = SHA1(Buffer) - 20 bytes
  
  prepared = <MessageType:1><Version:2><ContentLen+MacLen+PaddingLen:2><Content:Variable><digest:20>
  
  encrypted = ENCRYPT(prepared)
  
  toSend = <MessageType:1 = 0x17><Version:2><Length:2 = 0x0080><encrypted:128>
  
  MessageType 0x17 = Content Application Data
}
begin
  result := 1; // prepare for errors
  if (dataLength > 128) then
    begin
      result := 4; // data too long
      exit;
    end;
 // the Plan:
      //   1. calculate HMAC on associated data + outData
      //   2. Pad HMAC and verify data
      //   3. CBC encrypt padded message using client IV
      //   4. pack the message

      // 1. calculate HMAC on associated data + outData
      Mem_Set(@toEncrypt, 0, 254);
      // associated data // current sequence number, 8 bytes
      for i := 0 to 7 do
        toEncrypt[i] := sequenceNumber[i];
      
      // TLS record header
      toEncrypt[8]  := TLS_CONTENT_APPLICATION_DATA;
      toEncrypt[9]  := TLS_VERSION_HIGH;
      toEncrypt[10] := TLS_VERSION_LO;
      toEncrypt[11] := $00;     // Message length Hi
      toEncrypt[12] := dataLength;     // Record  length //todo: take high too

      for i := 0 to dataLength - 1 do
        begin
          toEncrypt[i + 13] := outData[i];
        end;

      // calculate HMAC SHA-1 of the message
      HMAC_ShaMd5(@client_write_MAC_secret,  // Secret
                  20,             // Secret length
                  @toEncrypt,     // Data to hash
                  dataLength + 13,// Data length
                  @messageHMAC ,  // Hash result
                  0);             // SHA-1
                  
      //2. concat outData and HMAC
      Mem_Set(@toEncrypt, 0, 254);

      // copy outData
      for i := 0 to dataLength - 1 do
        toEncrypt[i] := outData[i];

      // copy HMAC
      for i := 0 to 19 do
        toEncrypt[dataLength + i] := messageHMAC[i];
      // calculate number of padding bytes and their value
      i := 20 + dataLength;
      paddingByte := 0;
      while (i mod 16) <> 0 do
        begin
          inc(i);
          inc(paddingByte);
        end;
      limit := i;
      for i := dataLength + 20 to limit - 1 do
        toEncrypt[i] := paddingByte - 1; // for ex. if there are 5 bytes needed, all of them would have the value of 0x04

      //3. CBC encrypt
      result := AES_128_CBC_encrypt(@client_write_key, @client_write_IV, @toEncrypt, limit);
      if (result <> 0) then
        begin
          debugMsg := 'Encryption failed';
          TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
          TraceOut(toEncrypt, limit, 1, TRACE_TYPE_ERROR);
          result := 101;
        end
      else
        begin
            // 4. pack the message
            HTTP_data_out[0] := TLS_CONTENT_APPLICATION_DATA;
            HTTP_data_out[1] := TLS_VERSION_HIGH;
            HTTP_data_out[2] := TLS_VERSION_LO;
            HTTP_data_out[3] := $00;            // Message length Hi
            HTTP_data_out[4] := 16 + limit;     // Record  length Lo// todo: check hi byte

            // append client IV
            for i := 0 to 15 do
              HTTP_data_out[5 + i] := client_write_IV[i];

            for i := 0 to limit - 1 do
              HTTP_data_out[21 + i] := toEncrypt[i];

            messageLength := 16 + limit + 5;
            result := SendMessage(messageLength, false);
            if (result = 0) then
              begin
                IncrementSequenceNumber();
//              Note: The initialization vector to be used in next packet is the last 16 bytes of
//                  the previously sent packet:
                for i := 0 to 15 do
                  begin
                    client_write_IV[i] := HTTP_data_out[messageLength - 16];
                  end;
              end
            else
              begin
                // failed to send
              end;
        end;
end;


// return values:
//   0 - No Errors
//   1 - Socket not opened
//   2 - Timeout on send
//   3 - Socket Disconnected
//   4 - Data too long
// 101 - Encryption failed
function TLSSend128(var outData: array[1024] of byte; dataLength: word): byte;
var toSend: array[128] of byte;
    i, j: byte;
    len: byte;
    ptr: ^ byte;
begin
  result := 0;
  i := 0;
  // chop the message in 128 bytes chunks
  while (dataLength) > 0 do
    begin
      if (dataLength > 128) then
        begin
          dataLength := dataLength - 128;
          len := 128;
        end
      else
        begin
          len := dataLength;
          dataLength := 0;
        end;
      Mem_Cpy(@toSend, @outData + i * 128, len);
      
     ptr := @toSend;
      j := 0;
      while (j < len) do
        begin
//          if (ptr^ = 0) then
//            break;
//          UART3_write(ptr^);
          inc(ptr);
          inc(j);
        end;
      
      result := TLSSendInternal(toSend, len);
      if (result <> 0) then
        break;
      inc(i);
    end;
end;

// returns error code
//  dataLength contains number of bytes
// Return values:
//  0 - No Errors
//  1 - Server Alert
//  2 - Invalid Packet
//  3 - Invalid TLS version (Hi)
//  4 - Invalid TLS version (Lo)
//  5 - Failed to decrypt
function TLSReceive(var dataLength: word): byte;
var debugMsg: string[32];
    p: ^byte;
    msgSize: word;
    i, startIndex: word;
    tracelevel, traceType: byte;
    msgHmac: array[20] of byte;
begin
  dataLength := 0;
  result := 0;
  startIndex := 0;
  while (startIndex < host_response_len_ssl) do
    begin
      tracelevel := 6;
      traceType  := TRACE_TYPE_LOG;
      
      debugMsg := 'Received data';
      TraceOut(debugMsg, Str_Len(debugMsg), tracelevel, traceType);
      TraceOut(host_response, host_response_len_ssl, tracelevel, traceType);
      
      if (host_response[startIndex + 0] = TLS_CONTENT_ALERT) then
        begin
          tracelevel := 1;
          traceType  := TRACE_TYPE_ERROR;
          
          debugMsg := 'Server alert!';
          TraceOut(debugMsg, Str_Len(debugMsg), tracelevel, traceType);
          TraceOut(host_response, host_response_len_ssl, tracelevel, traceType);
          // todo: process alert
          result := 1; // server alert
        end
      else
        begin
            if (host_response[startIndex + 0] <> TLS_CONTENT_APPLICATION_DATA) then
              begin
                debugMsg := 'Invalid packet'; // todo: disconnect
                TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
                result  := 2; // invalid packet
                exit;
              end;

            if (host_response[startIndex + 1] <> TLS_VERSION_HIGH) then
                begin
                  debugMsg := 'Invalid TLS version'; // todo: disconnect
                  TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
                  result := 3;
                  exit;
                end;

            if (host_response[startIndex + 2] <> TLS_VERSION_LO) then
                begin
                  debugMsg := 'Invalid TLS version'; // todo: disconnect
                  TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
                  result := 4;
                  exit;
               end;

        Hi(msgSize) := host_response[startIndex + 3];
        Lo(msgSize) := host_response[startIndex + 4];
        startIndex := startIndex + msgSize; // in case there are other messages concatenated
        p := @host_response;

        for i := 5 to 20 do
          server_write_IV[i-5] := host_response[i];

        p := p + 5 + 16;

        i := 0;

          result := AES_128_CBC_decrypt(@Server_write_key, @server_write_IV, p, msgSize - 16); // -16 = skip IV
          if (result <> 0) then
            begin
              debugMsg := 'Failed to decrypt';
              TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
              result := 5;
            end
          else
            begin
              dataLength := msgSize - 16 - 20;// strip header (5), IV (16) and hMAC (20)
              for i := 0 to dataLength - 1 do
                begin
                  host_response[i] := host_response[i + 21];
                end;
              
              for i := dataLength to dataLength + 20 - 1 do
                begin
                  msgHmac[i] := host_response[i + 21 + dataLength];
                end;
              //todo: check hMAC
              
              // todo: check padding
              debugMsg := 'Decrypted';
              TraceOut(debugMsg, Str_Len(debugMsg), tracelevel, traceType);
              TraceOut(host_response, dataLength, tracelevel, traceType);
            end;
       end;
      inc(startIndex); // next message, if any
    end;
end;

//todo: refactor TLSSend. It is already used in ClientFinished
// return values:
//   0 - No Errors
//   1 - Socket not opened
//   2 - Timeout on send
//   3 - Socket Disconnected
//   4 - Data too long
// 101 - Encryption failed
function TLSSend(var outData: array[1024] of byte; dataLength: word): byte;
var i, limit: word;
    paddingByte: byte;
    messageHMAC: array[20] of byte;
    toEncrypt: array[1300] of byte;
    debugMsg: string[32];
    messageLength: word;
{
  Sequence number is never transmitted, encrypted or otherwise;
  its just prepended to the MAC buffer before the packet is MACed. Therefore,
  given a content buffer of content, the buffer that is MACed looks like this:

  buffer = <SeqNumber:8><MessageType:1><Version:2><ContentLength:2><Content:Variable>

  Digest is calculated over the buffer
  digest = MAC(buffer) = SHA1(Buffer) - 20 bytes

  prepared = <MessageType:1><Version:2><ContentLen+MacLen+PaddingLen:2><Content:Variable><digest:20>

  encrypted = ENCRYPT(prepared)

  toSend = <MessageType:1 = 0x17><Version:2><Length:2 = 0x0080><encrypted:128>

  MessageType 0x17 = Content Application Data
}
begin
  result := 1; // prepare for errors
  if (dataLength > 1024) then
    begin
      result := 4; // data too long
      exit;
    end;
 // the Plan:
      //   1. calculate HMAC on associated data + outData
      //   2. Pad HMAC and verify data
      //   3. CBC encrypt padded message using client IV
      //   4. pack the message

      // 1. calculate HMAC on associated data + outData
      Mem_Set(@toEncrypt, 0, 1300);
      // associated data // current sequence number, 8 bytes
      for i := 0 to 7 do
        toEncrypt[i] := sequenceNumber[i];

      // TLS record header
      toEncrypt[8]  := TLS_CONTENT_APPLICATION_DATA;
      toEncrypt[9]  := TLS_VERSION_HIGH;
      toEncrypt[10] := TLS_VERSION_LO;
      toEncrypt[11] := Hi(dataLength);     // Message length Hi
      toEncrypt[12] := Lo(dataLength);     // Record  length

      for i := 0 to dataLength - 1 do
        begin
          toEncrypt[i + 13] := outData[i];
        end;

      // calculate HMAC SHA-1 of the message
      HMAC_ShaMd5(@client_write_MAC_secret,  // Secret
                  20,             // Secret length
                  @toEncrypt,     // Data to hash
                  dataLength + 13,// Data length
                  @messageHMAC ,  // Hash result
                  0);             // SHA-1

      //2. concat outData and HMAC
      Mem_Set(@toEncrypt, 0, 1300);

      // copy outData
      for i := 0 to dataLength - 1 do
        toEncrypt[i] := outData[i];

      // copy HMAC
      for i := 0 to 19 do
        toEncrypt[dataLength + i] := messageHMAC[i];
      // calculate number of padding bytes and their value
      i := 20 + dataLength;
      paddingByte := 0;
      while (i mod 16) <> 0 do
        begin
          inc(i);
          inc(paddingByte);
        end;
      limit := i;
      for i := dataLength + 20 to limit - 1 do
        toEncrypt[i] := paddingByte - 1; // for ex. if there are 5 bytes needed, all of them would have the value of 0x04

      //3. CBC encrypt
      result := AES_128_CBC_encrypt(@client_write_key, @client_write_IV, @toEncrypt, limit);
      
      if (result <> 0) then
        begin
          debugMsg := 'Encryption failed';
          TraceOut(debugMsg, Str_Len(debugMsg), 1, TRACE_TYPE_ERROR);
          TraceOut(toEncrypt, limit, 1, TRACE_TYPE_ERROR);
          result := 101;
        end
      else
        begin
            // 4. pack the message
            messageLength := 16 + limit;
            
//            UART3_Write(' ');
//            Word2Str(messageLength, debugMsg);
//            UART3_Write_Text(debugMsg);
//            UART3_Write(' ');
            
            HTTP_data_out[0] := TLS_CONTENT_APPLICATION_DATA;
            HTTP_data_out[1] := TLS_VERSION_HIGH;
            HTTP_data_out[2] := TLS_VERSION_LO;
            HTTP_data_out[3] := Hi(messageLength);  // Message length Hi
            HTTP_data_out[4] := lo(messageLength);  // Record  length Lo

            // append client IV
            for i := 0 to 15 do
              HTTP_data_out[5 + i] := client_write_IV[i];

            for i := 0 to limit - 1 do
              HTTP_data_out[21 + i] := toEncrypt[i];

            messageLength := messageLength + 5; // add header
            result := SendMessage(messageLength, false);
            if (result = 0) then
              begin
                IncrementSequenceNumber();
//              Note: The initialization vector to be used in next packet is the last 16 bytes of
//                  the previously sent packet:
                for i := 0 to 15 do
                  begin
                    client_write_IV[i] := HTTP_data_out[messageLength - 16 + i];
                  end;
              end
            else
              begin
                // failed to send
              end;
        end;
end;


end.