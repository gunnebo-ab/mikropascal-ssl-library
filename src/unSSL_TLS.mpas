unit unSSL_TLS;

uses dspic_additional_string_library,lib_Delays_LIO,def_io,lib1_enc600_V3_5_b,
     enc_lib_user,lib2_enc600_V3_5_b,df_lib_SPI1,crc16_lib,
     Tftp_Server,config,HTTP_Send,definitions_ENC600,unX509Certificate;

procedure Random_Init;
procedure Random_Array_32(d_in : ^byte);
procedure Random_Array_46(d_in : ^byte);
procedure MD5SHA(dataIn : ^char; dataLength : word; shaMd5
                   , restoreContextID // 0 - none
                                      // 1 - SHA 1
                                      // 2 - MD5
                   , saveContextID    // 0 - none
                                      // 1 - SHA 1
                                      // 2 - MD5
                   : byte);
procedure MD5SHAFinal(dataIn, dataOut : ^char; dataLength : word; shaMd5, contextID: byte);
procedure HMAC_MD5SHA(secretKey : ^byte; secretKeyLength : word; textToHash : ^byte; textLength : word; var hmacResult :array[20] of byte; shaMd5 : byte);
procedure AES_128_CBC_encrypt(key16, iv16, text : ^char; text_len : word);
procedure AES_128_CBC_decrypt(key16, iv16, text : ^char; text_len : word);
procedure modexp(var y : array[128] of byte;
                 var e : array[128] of byte; e_len : word;
                 var x : array[128] of byte; x_len : word;
                 var m : array[128] of byte; m_len : word);
procedure SSL_Init;
procedure HTTPProcDataIn_SSL(len_ : word; j : byte);
function OpenTCPConnection_SSL(port : word) : boolean;
function SendTCP_SSL(len : word) : boolean;
function SendTCPwait_SSL(len : word) : boolean;
function Open_SSL(port : word) : boolean;
procedure PRF(secretKey: ^byte; secretKeyLength: word;
              aLabel: ^byte; labelLength: word;
              seed: ^byte; seedLength: word;
              prfOut: ^byte; prfLength: word);
              
procedure AddToHash(hashByte: byte; ShaMD5: byte);

type TtoHash = record
  hashed: boolean;           // indicates if dataIn is hashed
  firstBlock: boolean;       // if set, then hash engine is reset
  dataLength: byte;          // current length of dataIn
  dataIn: array[65] of byte; // data to be hashed, 65 because we will always transfer one byte to the next iteration
end;
 var toHashMD5, toHashSHA1: TtoHash; // todo: should be local

implementation

const HASHLST = 12;   // ECON1
      HASHOP  = 13;   // ECON1
      HASHEN  = 14;   // ECON1
      SHA1MD5 = 12;   // ECON2
      HASHIF  = 13;   // EIR
      
const TLS_HELLO_REQUEST       =  0x00; //  0
      TLS_CLIENT_HELLO        =  0x01; //  1
      TLS_SERVER_HELLO        =  0x02; //  2
      TLS_CERTIFICATE         =  0x0B; // 11
      TLS_SERVER_KEY_EXCHANGE =  0x0C; // 12
      TLS_CERTIFICATE_REQUEST =  0x0D; // 13
      TLS_SERVER_HELLO_DONE   =  0x0E; // 14
      TLS_CERTIFICATE_VERIFY  =  0x0F; // 15
      TLS_CLIENT_KEY_EXCHANGE =  0x10; // 16
      TLS_FINISHED            =  0x14; // 20
      


type TPreMasterSecret = record
  clientVersion: array[2] of byte;
  random: array[46] of byte;
end;

var m_z,m_w,m_r : dword;
var MD5_buff, SHA1_buff : array[28] of byte;

var ServerCertificate: TX509Certificate;
var MD5Hash: array[16] of char;
var SHA1Hash: array[20] of char;
var masterSecret: array[48] of byte;
var preMasterSecret: TPreMasterSecret;

var serverRandom: array[32] of char; // todo: restore to byte
var clientRandom: array[32] of byte;

var serverCipherSuite: array[2] of byte;
var serverCompressionMethod: byte;

procedure Random_Init;
begin
  LoWord(m_z) := TMR1;
  HiWord(m_z) := TMR1+127;
  LoWord(m_w) := TMR1+369;
  HiWord(m_w) := TMR1+768;
end;

function Random : dword;
begin
  m_z := 36969 * (m_z and 65535) + (m_z shr 16);
  m_w := 18000 * (m_w and 65535) + (m_w shr 16);
  result := (m_z shl 16) + m_w;
end;

procedure AnalyzeRandom;
begin
  m_r := Random;
  while ((Lo(m_r) = 0) or (Hi(m_r) = 0) or (Higher(m_r) = 0) or (Highest(m_r) = 0)) do m_r := Random;
end;

// number of bytes must be divisible by 4
procedure Random_Array(randomData : ^byte; numberOfBytes: byte);
var i : word;
begin
  numberOfBytes := numberOfBytes div 4;
  i := 0;
  while i < numberOfBytes do
    begin
      AnalyzeRandom;
      randomData^ := Lo(m_r);
      inc(randomData);
      randomData^ := Hi(m_r);
      inc(randomData);
      randomData^ := Higher(m_r);
      inc(randomData);
      randomData^ := Highest(m_r);
      inc(randomData);
      inc(i);
    end;
end;

procedure Random_Array_32(d_in : ^byte);
var i : word;
begin
  i := 0;
  while i < 8 do
    begin
      AnalyzeRandom;
      d_in^ := Lo(m_r);
      inc(d_in);
      d_in^ := Hi(m_r);
      inc(d_in);
      d_in^ := Higher(m_r);
      inc(d_in);
      d_in^ := Highest(m_r);
      inc(d_in);
      inc(i);
    end;
end;

procedure Random_Array_46(d_in : ^byte);
var i : byte;
begin
  i := 0;
  while i < 11 do
    begin
      AnalyzeRandom;
      d_in^ := Lo(m_r);
      inc(d_in);
      d_in^ := Hi(m_r);
      inc(d_in);
      d_in^ := Higher(m_r);
      inc(d_in);
      d_in^ := Highest(m_r);
      inc(d_in);
      inc(i);
    end;
  // two more bytes to make it 46
  AnalyzeRandom;
  d_in^ := Lo(m_r);
  inc(d_in);
  d_in^ := Hi(m_r);
end;

procedure dma_write(addr : word; d_in : ^char; len : word);
begin
  CopyRamToEthMem(d_in, $680, len);
  CopyEthMemToEthMem($680,addr,len);
end;

procedure dma_read(addr : word; d_out : ^char; len : word);
begin
  CopyEthMemToEthMem(addr,$680,len);
  CopyEthMemToRam($680,d_out,len);
end;

procedure MD5SHA(  dataIn : ^char;
                   dataLength : word; 
                   shaMd5             // 0 - SHA1, 1 - MD5
                   , restoreContextID // 0 - none
                                      // 1 - SHA 1
                                      // 2 - MD5
                   , saveContextID    // 0 - none
                                      // 1 - SHA 1
                                      // 2 - MD5
                   : byte);
var i : word;
    buf : word;
begin
  buf := Eth_ReadReg(ECON2_);
  if shaMd5 = 1 then
    begin
//      UART3_Write_Text('.MD5SHA-M D 5.');
      buf.SHA1MD5 := 0;           // MD5
      shaMd5 := 16;
    end
  else
    begin
//      UART3_Write_Text('.MD5SHA-S H A 1.');
      buf.SHA1MD5 := 1;           // SHA1
      shaMd5 := 20;
    end;
  Eth_WriteReg(ECON2_, buf);
  
  buf := Eth_ReadReg(ECON1_);

  if restoreContextID = 2 then
    begin
//      UART3_Write_Text('.MD5SHA-m.');
      dma_write(0x7A40, @MD5_buff, 28);
      buf.HASHOP := 1; // continue prev hash
    end
  else if restoreContextID = 1 then
    begin
//      UART3_Write_Text('.MD5SHA-s.');
      dma_write(0x7A40, @SHA1_buff, 28);
      buf.HASHOP := 1; // continue prev hash
    end
  else
    begin
      buf.HASHOP := 0; // begin a new hash
    end;

  buf.HASHEN := 1;
  i := 0;
  if dataLength > 64 then
    begin
      buf.HASHLST := 0;           // HASHLST

      Eth_WriteReg(ECON1_, buf);
      while dataLength > 64 do
        begin
//          UART3_Write_Text('Here 1.');
          buf := Eth_ReadReg(EIR_);
          buf.HASHIF := 0;           // HASHIF
          Eth_WriteReg(EIR_, buf);
          dma_write(0x7A00, dataIn + i, 64);
          while (Eth_ReadReg(EIR_) and $2000) = 0 do delayms(1); // HASHIF
          dataLength := dataLength - 64;
          i := i + 64;
        end;

      if saveContextID = 2 then
        begin
//          UART3_Write_Text('.MD5SHA-mm.');
          dma_read(0x7A70, @MD5_buff, 28);
        end
      else if saveContextID = 1 then
        begin
//          UART3_Write_Text('.MD5SHA-ss.');
          dma_read(0x7A70, @SHA1_buff, 28);
        end;
    end;

  buf := Eth_ReadReg(ECON1_);
  buf.HASHEN := 0;           // HASHEN
  Eth_WriteReg(ECON1_, buf);
end;

procedure MD5SHAFinal(dataIn, dataOut : ^char; dataLength : word; shaMd5, restoreContextID: byte);
var buf : word;
begin
  buf := Eth_ReadReg(ECON2_);
  if shaMD5 = 1 then // MD5
    shaMD5 := 16
  else
    shaMD5 := 20;
  Eth_WriteReg(ECON2_, buf);
  
  buf := Eth_ReadReg(ECON1_);
  if restoreContextID = 2 then
    begin
//      UART3_Write_Text('.final-md5.');
      dma_write(0x7A40, @MD5_buff, 28);
      buf.HASHOP := 1; // continue prev hash
    end
  else if restoreContextID = 1 then
    begin
//      UART3_Write_Text('.final-sha1.');
      dma_write(0x7A40, @SHA1_buff, 28);
      buf.HASHOP := 1; // continue prev hash
    end
  else
    begin
      buf.HASHOP := 0; // begin a new hash
    end;
  
  buf.HASHEN := 1;
  buf.HASHLST := 1;
  Eth_WriteReg(ECON1_, buf);
  
  buf := Eth_ReadReg(EIR_);
  buf.HASHIF := 0;
  Eth_WriteReg(EIR_, buf);
  
  if dataLength > 0 then  // must be <= 64
    begin
      dma_write(0x7A00, dataIn, dataLength);
      while (Eth_ReadReg(EIR_) and $2000) = 0 do // HASHIF
        delayms(1);
    end;
  dma_read(0x7A70, dataOut, shaMD5);
  buf := Eth_ReadReg(ECON1_);
  buf.HASHEN := 0;
  Eth_WriteReg(ECON1_, buf);
end;


//******************************************************************************
//
//
//
//******************************************************************************
procedure AddToHash(hashByte: byte; ShaMD5: byte);
var save, restore: byte;
    tmp: array[64] of byte;
    i: byte;
begin
  if ShaMD5 = 0 then
    begin
//      UART3_Write_Text('.SHA1.');
      toHashSHA1.hashed := false; // new data is pending
      toHashSHA1.dataIn[toHashSHA1.dataLength] := hashByte;
      toHashSHA1.dataLength := toHashSHA1.dataLength + 1;
      if (toHashSHA1.dataLength > 64) then  // do it only if another byte is pending after this block(because of the call to final)
        begin // hash the current block
          save := 1; // always save the context
          if toHashSHA1.firstBlock <> 0 then
            begin // we do not restore on the first block
              restore := 0;
            end
          else
            begin
              restore := 1;
            end;
          for i := 0 to 63 do
            tmp[i] := toHashSHA1.dataIn[i];
          MD5SHA(@tmp, // data to be hashed
                 65,                    // 64B actually, but the extra one will trigger a proper procedure
                 0,                     // SHA1
                 restore,               // context
                 save                   // context
                 );
          toHashSHA1.dataLength := 1; // one byte remained, move it to next iteration
          toHashSHA1.dataIn[0] := toHashSHA1.dataIn[64]; // this is the orphan that was not hashed
          toHashSHA1.hashed := true;    // not really needed?
          toHashSHA1.firstBlock := false;
        end;
    end
  else
    begin
//      UART3_Write_Text('.MD5.');
      toHashMD5.hashed := false; // new data is pending
      toHashMD5.dataIn[toHashMD5.dataLength] := hashByte;
      toHashMD5.dataLength := toHashMD5.dataLength + 1;
      if (toHashMD5.dataLength > 64) then // do it only if another byte is pending after this block (because of the call to final)
        begin // hash the current block
          save := 2; // always save the context
          if toHashMD5.firstBlock <> 0 then
            begin // we do not restore on the first block
              restore := 0;
            end
          else
            begin
              restore := 2;
            end;
          for i := 0 to 63 do
            tmp[i] := toHashMD5.dataIn[i];
          MD5SHA(@tmp, // data to be hashed
                 65,                   // 64B actually, but the extra one will trigger a proper procedure
                 1,                    // MD5
                 restore,              // context
                 save);                // context

          toHashMD5.dataLength := 1; // one byte remained, move it to next iteration
          toHashMD5.dataIn[0] := toHashMD5.dataIn[64]; // this is the orphan that was not hashed
                                                       // move it to the next block
          toHashMD5.hashed := true;    // not really needed?
          toHashMD5.firstBlock := false;
        end;
    end;
end;

procedure HMAC_MD5SHA(secretKey : ^byte; secretKeyLength : word; textToHash : ^byte; textLength : word; var hmacResult :array[20] of byte; shaMd5 : byte);
const BLOCK_SIZE = 64;
var ipad, opad : array[BLOCK_SIZE + 1] of char;
    i : word;
    isha: array [20] of byte;
    buf: array[BLOCK_SIZE] of byte;
    digestSize: byte;
    secretKeyHash: array[BLOCK_SIZE] of byte;
    saveContext, restoreContext: byte;
begin
  if shaMd5 = 0 then
    begin
      digestSize := 20;
      restoreContext := 1;
      saveContext := 1;
    end
  else
    begin
      digestSize := 16;
      restoreContext := 2;
      saveContext := 2;
    end;
    
  if secretKeyLength > BLOCK_SIZE then
    begin
        MD5SHA(secretKey, secretKeyLength, shaMd5, 0, saveContext);
        i := secretKeyLength div BLOCK_SIZE;
        i := i * BLOCK_SIZE;                     // completed bytes
        secretKeyLength := secretKeyLength mod BLOCK_SIZE; // remaining bytes

        MD5SHAFinal(secretKey + i, @secretKeyHash, secretKeyLength, shaMd5, restoreContext);
    end
  else
    begin
      for i := 0 to secretKeyLength - 1 do
        begin
          secretKeyHash[i] := secretKey^;
          inc(secretKey);
        end;
    end;

  //**** Inner Digest ****/
  Mem_Set(@ipad, 0x36, BLOCK_SIZE);
  Mem_Set(@opad, 0x5c, BLOCK_SIZE);
   
  for i := 0 to secretKeyLength - 1 do
     begin
       ipad[i] := ipad[i] xor secretKeyHash[i];
       opad[i] := opad[i] xor secretKeyHash[i];
     end;
  
  i := 0;
  MD5SHA(@ipad, BLOCK_SIZE + 1, shaMd5, 0, saveContext);
  if textLength > BLOCK_SIZE then
     begin
        MD5SHA(textToHash, textLength, shaMd5, restoreContext, saveContext);
        i := textLength div BLOCK_SIZE;
        i := i * BLOCK_SIZE;                     // completed bytes
        textLength := textLength mod BLOCK_SIZE; // remaining bytes
     end;
  MD5SHAFinal(textToHash + i, @isha, textLength, shaMd5, restoreContext);

  //**** Outter Digest ****
  MD5SHA(@opad, BLOCK_SIZE + 1, shaMd5, 0, restoreContext);
  MD5SHAFinal(@isha, @hmacResult, digestSize, shaMd5, restoreContext);
end;

procedure AES_128_CBC_encrypt(key16, iv16, text : ^char; text_len : word);
var blocks,i,buf : word;
begin
  if (text_len mod 16) = 0 then nop else exit;

  blocks := text_len div 16;

  while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for AES engine to be free...

  buf := Eth_ReadReg(ECON2_);
  buf.0 := 0;           // AESLEN 128-bit key
  buf.1 := 0;           // AESLEN 128-bit key
  Eth_WriteReg(ECON2_, buf);

  dma_write(0x7C00, key16, 16);

  buf := Eth_ReadReg(ECON1_);
  buf.11 := 1;           // AESST
  Eth_WriteReg(ECON1_, buf);
  while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for key to be loaded

  buf := Eth_ReadReg(ECON1_);
  buf.9 := 1;           // AESOP CBC encrypt
  buf.10 := 0;           // AESOP CBC encrypt
  Eth_WriteReg(ECON1_, buf);

  dma_write(0x7C20, iv16, 16);

  i := 0;
  while i < blocks do
    begin
      // write the next block ...
      dma_write(0x7C30, text + i*16, 16);
      buf := Eth_ReadReg(ECON1_);
      buf.11 := 1;           // AESST start encryption
      Eth_WriteReg(ECON1_, buf);
      while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for completion
      dma_read(0x7C20, text + i*16, 16);
      inc(i);
  end;
end;

procedure AES_128_CBC_decrypt(key16,iv16,text : ^char; text_len : word);
var blocks,i,buf : word;
begin
  if (text_len mod 16) = 0 then nop else exit;

  blocks := text_len div 16;

  while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for AES engine to be free...

  buf := Eth_ReadReg(ECON2_);
  buf.0 := 0;           // AESLEN 128-bit key
  buf.1 := 0;           // AESLEN 128-bit key
  Eth_WriteReg(ECON2_, buf);

  dma_write(0x7C00, key16, 16);

  buf := Eth_ReadReg(ECON1_);
  buf.11 := 1;           // AESST
  Eth_WriteReg(ECON1_, buf);
  while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for key to be loaded

  buf := Eth_ReadReg(ECON1_);
  buf.9 := 0;           // AESOP CBC decrypt
  buf.10 := 1;          // AESOP CBC decrypt
  Eth_WriteReg(ECON1_, buf);

  dma_write(0x7C30, iv16, 16);

  i := 0;
  while i < blocks do
    begin
      // write the next block ...
      dma_write(0x7C20, text + i*16, 16);
      buf := Eth_ReadReg(ECON1_);
      buf.11 := 1;           // AESST start decryption
      Eth_WriteReg(ECON1_, buf);
      while (Eth_ReadReg(ECON1_) and $0800) <> 0 do delayms(1); // AESST wait for completion
      dma_read(0x7C40, text + i*16, 16);
      CopyEthMemToEthMem(0x7C40,0x7C30,16);
      inc(i);
    end;
end;

procedure modexp(var y : array[128] of byte;
                 var e : array[128] of byte; e_len : word;
                 var x : array[128] of byte; x_len : word;
                 var m : array[128] of byte; m_len : word);
var buf : array[128] of byte;
    buf1 : word;
begin
  // Only 512, 768, and 1024 bit moduli are supported
  if (m_len <> 64) and (m_len <> 96) and (m_len <> 128) then exit;

  // e and x must be strictly less than m
  if (e_len > m_len) or (x_len > e_len) then exit;

{ datasheet 15.1
      "For the Modular Exponentiation engine to work correctly, the
      Most Significant (MSb) bit of M must be set."
}

  if (m[0] and 0x80) = 0 then exit;

  // left-pad e, x with zeros
  Mem_Set(@buf, 0, m_len);
  Mem_Cpy(@buf + m_len - e_len, @e, e_len);
  dma_write(0x7800, @buf, m_len);

  Mem_Set(@buf, 0, m_len);
  Mem_Cpy(@buf + m_len - x_len, @x, x_len);
  dma_write(0x7880, @buf, m_len);

  dma_write(0x7900, @m, m_len);

  buf1 := Eth_ReadReg(ECON2_);
  buf1.2 := 0;                              // MODLEN 64
  buf1.3 := 0;                              // MODLEN 64
  if m_len = 96 then buf1.2 := 1            // MODLEN 96
  else if m_len = 128 then buf1.3 := 1;     // MODLEN 128
  Eth_WriteReg(ECON2_, buf1);

  buf1 := Eth_ReadReg(ECON1_);
  buf1.15 := 1;           // MODEXST enable modexp engine
  Eth_WriteReg(ECON1_, buf1);
  while (Eth_ReadReg(ECON1_) and $8000) <> 0 do delayms(1);

  dma_read(0x7880, @y, m_len);
end;

procedure out_broadcast_local(port,len : word; var d_in : array[4096] of char);
var broadcast_ip : array[4] of byte;
var i,j : word;
    buf : string[1300];
begin
  broadcast_ip[0] := 255;
  broadcast_ip[1] := 255;
  broadcast_ip[2] := 255;
  broadcast_ip[3] := 255;

  j := 0;
  while len <> 0 do
    begin
      i := len;
      if i > 1280 then i := 1280;

      Mem_Cpy(@buf,@d_in[j],i);

      Send_UDP_Broadcast(broadcast_ip,port,port,i,buf);
      Do_EthernetProc;

      j := j + i;
      len := len - i;
    end;
end;

procedure SSL_Init;
begin
  HTTP_send_Port_ssl := TMR1 + 23456;
  certificate_len := 0;
  host_response_len_ssl := 0;
end;

procedure HTTPProcDataIn_SSL(len_ : word; j : byte);
var max_len : word;
label next_;
begin
  Socket[j].Keep_Alive := true;

  if host_response_len_ssl >= 4096 then exit;

  if host_response_len_ssl <> 0 then    // one packet arrived
    begin
      max_len := 4096 - host_response_len_ssl;
      if len_ > max_len then len_ := max_len;
    end;

  CopyEthMem_CPToRam(@host_response[host_response_len_ssl], len_);
  host_response_len_ssl := host_response_len_ssl + len_;
end;

function OpenTCPConnection_SSL(port : word) : boolean;
var i : word;
label end_end_,again_;
begin
  i := 0;

again_:

  Wait_With_Eth(100);

  result := false;
//  UART3_Write_Text('here -1');
  if Str_Len(server_address_url) < 3 then exit;

  if IsIP(server_address_url) <> 0 then
    begin
      Str2IP(server_address_url,server_addr);
    end
  else
    begin
//      UART3_Write_Text('here 0');
      if Dns_Resolve(server_address_url,server_addr) = false then
        begin
//          UART3_Write_Text('here 1');
          if Dns_Resolve(server_address_url,server_addr) = false then
            begin
              //if UDP_debug <> 0 then
                begin
                  Socket_TCP_buf := 'DNS fail';
                  out_broadcast_local(33335,Str_Len(Socket_TCP_buf),Socket_TCP_buf);
                end;
              goto end_end_;
            end
          else
            begin
            //  if UDP_debug <> 0 then
                begin
                  Socket_TCP_buf := 'DNS resolved';
                  out_broadcast_local(33335, Str_Len(Socket_TCP_buf), Socket_TCP_buf);
                end;
            end;
        end
      else
        begin
          Socket_TCP_buf := 'DNS resolved';
          out_broadcast_local(33335, Str_Len(Socket_TCP_buf),Socket_TCP_buf);
          Mem_Cpy(@Socket_TCP_buf, @server_addr, 4);
          out_broadcast_local(33335, 4, Socket_TCP_buf);
        end;
    end;
  o_sock_ssl := 11;

  Close_TCP_Connection_Advance(o_sock_ssl);   // we use tcp socket 11

  TCP_Close_Port(HTTP_send_Port_ssl);

  HTTP_send_Port_ssl := HTTP_send_Port_ssl + 1;

  if HTTP_send_Port_ssl > 65000 then HTTP_send_Port_ssl := TMR1 + 23456;

  TCP_Open_Port(HTTP_send_Port_ssl);

  if Open_TCP_Connection_Advance(server_addr,port,HTTP_send_Port_ssl,o_sock_ssl) <> 0 then
    begin
      result := true;
      exit;
    end;

end_end_:
  if i < 2 then
    begin
      inc(i);
      goto again_; // try one more time
    end;
end;

function SendTCP_SSL(len : word) : boolean;
begin

  Wait_With_Eth(100);
  result := false;

  if Socket[o_sock_ssl].State_S <> 2 then exit;

      if UDP_debug <> 0 then
        begin
          out_broadcast_local(33335,len,HTTP_data_out);
        end;

      Socket[o_sock_ssl].RAM_ROM := 0;
      Socket[o_sock_ssl].Keep_Alive := true;
      Socket[o_sock_ssl].Exp_Time_Val := 100;
      Socket[o_sock_ssl].Do_Not_Fragment := 1;
      Socket[o_sock_ssl].Start_addr := @HTTP_data_out;
      Socket[o_sock_ssl].Stop_addr := Socket[o_sock_ssl].Start_addr + len;

      CC0_TCP := 0;
      while Socket[o_sock_ssl].State_S = 2 do      // while connected
        begin
          if CC0_TCP > 49 then break; // fail in 4 sec
          if Socket[o_sock_ssl].Start_addr = Socket[o_sock_ssl].Stop_addr then
            begin
              result := true;
              exit;
            end;
          Do_EthernetProc;
          Process_DHCP;
        end;
end;

function SendTCPwait_SSL(len : word) : boolean;
begin

  Wait_With_Eth(100);

  result := false;

  if Socket[o_sock_ssl].State_S <> 2 then exit;

      if UDP_debug <> 0 then
        begin
          out_broadcast_local(33335, len, HTTP_data_out);
        end;

      Socket[o_sock_ssl].RAM_ROM := 0;
      Socket[o_sock_ssl].Keep_Alive := true;
      Socket[o_sock_ssl].Exp_Time_Val := 100;
      Socket[o_sock_ssl].Do_Not_Fragment := 1;
      Socket[o_sock_ssl].Start_addr := @HTTP_data_out;
      Socket[o_sock_ssl].Stop_addr := Socket[o_sock_ssl].Start_addr + len;

      host_response := '';
      host_response_len := 0;

      CC0_TCP := 0;
      while Socket[o_sock_ssl].State_S = 2 do      // while connected
        begin
          if CC0_TCP > 49 then break; // fail in 4 sec
          if host_response_len_ssl <> 0 then
            begin
              result := true;
              break;
            end;
          Do_EthernetProc;
          Process_DHCP;
        end;
end;

function CreateClientKeyExchange: word; // returns number of bytes
var rsaCipherText: array[128] of byte; // 1024 bits
    i: byte;
    p: ^byte;
begin
      // choose pre master secret
      Random_Array_46(@preMasterSecret.random);
      // set the TLS version
      preMasterSecret.clientVersion[0] := 0x03;
      preMasterSecret.clientVersion[1] := 0x02;
      
      // encrypt the premaster secret
      //  1. extend the pre master secret to 1024 bit (128 bytes) integer by adding Random
      //  2. use HTTP_data_out as a temporary storage
      //  3. form the 1024 bit integer (128 bytes) as 00 01 <PS> 00 <Pre Master Secret>
      Mem_Set(@HTTP_data_out, 0, 256);
      HTTP_data_out[0]  := $00;
      HTTP_data_out[1]  := $01;
      // form PS, 77 bytes in length
      Random_Array_32(@HTTP_data_out[2]); // from 2 to 33, inclusive
      Random_Array_46(@HTTP_data_out[34]); // from 34 to 79, inclusive
      // note: this makes it 78 bytes in total, therefore we will trim the last byte
      
      HTTP_data_out[79] := 0x00;
      HTTP_data_out[80] := preMasterSecret.clientVersion[0]; // version hi
      HTTP_data_out[81] := preMasterSecret.clientVersion[1]; // version lo
      // append pre master secret random
      for i := 0 to 45 do
        begin
           HTTP_data_out[82 + i] := preMasterSecret.random[i];
        end;
      
      // RSA encrypt PreMaster Secret
      modexp(rsaCipherText,
             ServerCertificate.PublicKey.Key.Exponent,
             ServerCertificate.PublicKey.Key.ExponentLength,
             HTTP_data_out, // pre master length
             128,   // PreMasterSecret length
             ServerCertificate.PublicKey.Key.Base,
             ServerCertificate.PublicKey.Key.BaseLength
             );

      // build a "Client Key Exchange" message
      Mem_Set(@HTTP_data_out, 0, 256);

      // 1. TLS record header
      HTTP_data_out[0]  := $16;     // content type = handhsake
      HTTP_data_out[1]  := $03;     // protocol version
      HTTP_data_out[2]  := $02;     // protocol version, TLS 1.1

      HTTP_data_out[3]  := $00;     // Record length Hi
      HTTP_data_out[4]  := $82;     // Record length Lo - total 132 bytes after this byte

      HTTP_data_out[5]  := $10;     // ClientKeyExchange message type
      
      HTTP_data_out[6]  := $00;     // Message length Higher
      HTTP_data_out[7]  := $00;     // Message length Hi
      HTTP_data_out[8]  := $80;     // Message length Lo - 128 bytes
      
      // copy rsaCipherText back to HTTP_data_out
       for i := 0 to 127 do
         begin
           HTTP_data_out[9 + i] := rsaCipherText[i];
         end;
      
      result := 137;
end;

function CreateClientHello: word; // returns number of bytes
var i: byte;
begin
      // build a "Client Hello" message
      Mem_Set(@HTTP_data_out, 0, 256);

      // 1. TLS record header
      HTTP_data_out[0]  := $16;     // content type = handhsake
      HTTP_data_out[1]  := $03;     // protocol version
      HTTP_data_out[2]  := $02;     // protocol version, TLS 1.1

      HTTP_data_out[3]  := $00;     // content length HiByte
      HTTP_data_out[4]  := $2f;     // content length LoByte => 47B in total after this point

      // 2. Handshake header, hashing starts here
      HTTP_data_out[5]  := TLS_CLIENT_HELLO;     // handshake type code = 1 => clienthello
      HTTP_data_out[6]  := $00;     // length
      HTTP_data_out[7]  := $00;     // length
      HTTP_data_out[8]  := $2b;     // length = 43 bytes from this point onwards

      // 3. client hello starts here
      HTTP_data_out[9]  := $03;      // protocol version
      HTTP_data_out[10] := $02;      // protocol version, TLS 1.1

      // client Random
      Random_Array_32(@clientRandom);
      for i := 0 to 31 do
        HTTP_data_out[i + 11] := clientRandom[i]; // from 11 to 42, inclusive

      HTTP_data_out[43] := $00;     // session id byte length, 0 bytes for client hello (no session yet)

      HTTP_data_out[44] := $00;     // ciphersuite list length, hiByte
      HTTP_data_out[45] := $04;     // ciphersuite list length, loByte = 4 integers, i.e. 8 bytes

      HTTP_data_out[46] := $00;     // ciphersuite list
      HTTP_data_out[47] := $2f;     // ciphersuite list, single ciphersuite TLS_RSA_WITH_AES_128_CBC_SHA

      HTTP_data_out[48] := $00;     // no regotiation supported
      HTTP_data_out[49] := $ff;     // no regotiation supported

      HTTP_data_out[50] := $01;     // compression list
      HTTP_data_out[51] := $00;     // compression list, 'null' (no-op) compression
      
      result := 52;
end;

function CreateChangeCipher: word; // returns number of bytes
begin
      // build a "Change Cipher" message
      Mem_Set(@HTTP_data_out, 0, 256);

      // 1. TLS record header
      HTTP_data_out[0]  := $14;     // content type = change cipher
      HTTP_data_out[1]  := $03;     // protocol version
      HTTP_data_out[2]  := $02;     // protocol version, TLS 1.1

      HTTP_data_out[3]  := $00;     // Message length Hi
      HTTP_data_out[4]  := $01;     // Record length Lo - 1 byte only

      HTTP_data_out[5]  := $01;     // ChangeCipherSpec
      result := 6;
end;

procedure CalculateMasterSecret(var masterSecretOut: array[48] of byte);
var aLabel : string[13];
    seed: array[64] of byte;
    var i: byte;
begin
  aLabel := 'master secret';

  // seed = ClientHello.random + ServerHello.random
  for i := 0 to 31 do
    seed[i] := clientRandom[i];

  for i := 0 to 31 do
    seed[i + 32] := serverRandom[i];

  PRF(@preMasterSecret,
      46,               // pre master key length
      @aLabel,          // label
      13,               // label length
      @seed,            // ClientHello.random + ServerHello.random
      64,               // seed length
      @masterSecretOut, // out masterSecret
      48);              // masterSecret length
end;

procedure CalculateVerifyData(var verifyDataOut: array[12] of byte);
var seed: array[36] of byte;   //md5 (16 bytes) + sha-1 (20 bytes)
    i: byte;
    aLabel: string[15];
begin
      aLabel := 'client finished';
      // copy MD5
      for i := 0 to 15 do
        begin
          seed[i + 15] := MD5Hash[i];
        end;
      // copy SHA-1
      for i := 0 to 19 do
        begin
          seed[i + 15 + 16] := SHA1Hash[i];
        end;

     // compute verify data
     Prf(@MasterSecret,
         48,             // Master Secret Length
         @aLabel,        // label
         15,             // label length
         @seed,          // seed
         36,             // seed length
         @verifyDataOut,   // verify_data
         12);            // verify_data length
end;

function CreateClientFinished(): word; // returns number of bytes
var i: byte;
    verifyData: array[12] of byte;
begin
   // prepare data
      // compute master secret
      CalculateMasterSecret(masterSecret);
     
      // compute verify data
      CalculateVerifyData(verifyData);
//      UART3_Write(0x55);
      // build a "client finished" message
      Mem_Set(@HTTP_data_out, 0, 256);
      
      // 1. TLS record header
      HTTP_data_out[0]  := $16;     // content type = handshake
      HTTP_data_out[1]  := $03;     // protocol version
      HTTP_data_out[2]  := $02;     // protocol version, TLS 1.1

      HTTP_data_out[3]  := $00;     // Message length Hi
      HTTP_data_out[4]  := $10;     // Record  length Lo - 16 bytes
      
      // add TLS handshake header 14 00 00 0C
      HTTP_data_out[5] := 0x14;
      HTTP_data_out[6] := 0x00;
      HTTP_data_out[7] := 0x00;
      HTTP_data_out[8] := 0x0C;

      // append verify data
      for i := 0 to 11 do
        begin
           HTTP_data_out[9 + i] := verifyData[i];
        end;

      result := 21;
      
      exit;
      
      

      // 1. TLS record header
      HTTP_data_out[0]  := $16;     // content type = handshake
      HTTP_data_out[1]  := $03;     // protocol version
      HTTP_data_out[2]  := $02;     // protocol version, TLS 1.1

      HTTP_data_out[3]  := $00;     // Message length Hi
      HTTP_data_out[4]  := $40;     // Record length Lo - 64 bytes

      // random IV, 16 bytes, indexed from 5 to 20 inclusive
      Random_Array(@HTTP_data_out[5], 16);

      // add AD, sequence number and header for content type, 00 00 00 00 00 00 00 00 16 03 02 00 10
      for i := 20 to 27 do
        HTTP_data_out[i] := 0x00;
      HTTP_data_out[28] := 0x16;  // handshake ContentType
      HTTP_data_out[29] := 0x03;  // version
      HTTP_data_out[30] := 0x02;  // version TLS 1.1
      HTTP_data_out[31] := 0x00;  // length hi
      HTTP_data_out[32] := 0x10;  // length lo (16 bytes of hmac follows)

      // add TLS handshake header 14 00 00 0C
      HTTP_data_out[33] := 0x14;
      HTTP_data_out[34] := 0x00;
      HTTP_data_out[35] := 0x00;
      HTTP_data_out[36] := 0x0C;

      // append verifyData, indexed from 36 to 47 inclusive
      for i := 0 to 11 do
        begin
           HTTP_data_out[36 + i] := verifyData[i];
        end;

      // calculate HMAC, from index  20 to 47

      
      // todo
      result := 53;
end;

//** error codes:
//  0 - no error
//  1 - unknown error
//  2 - server hello expected
//  3 - server certificate expected
//  4 - server hello done expected
//  5 - Client Key Exchange not sent
//  6 - Client ChangeCipher not sent
//  7 - Client Finished not sent
function Open_SSL(port : word) : boolean;
var
    serverResponseLength: word;
    locali: word;
    startIndex, stopIndex: word;
    certificateLength: dword;
    helloDoneLength: word;
    sessionIDLength: byte;
    // todo: session id goes to record parameters
    sessionID: array[32] of byte; // careful here, the length can be longer
    extensionsLength: word;

    serverCertificateLength: dword;
    serverCertificateStartIndex: word;
    ptr: ^byte;
    messageLength: word;
    debugMsg: string[32];
begin
  result := 1;
  certificate_len := 0;
  if OpenTCPConnection_SSL(port) <> 0 then
    begin
      toHashMD5.firstBlock := TRUE; // start a new hash
      toHashMD5.dataLength := 0;
      
      toHashSHA1.firstBlock := TRUE; // start a new hash
      toHashSHA1.dataLength := 0;
      
      messageLength := CreateClientHello();
      if SendTCPwait_SSL(messageLength) <> 0 then
        begin
          // we need to hash everything in client hello, except TLS headers, index from 5 to 51
          for locali := 5 to 51 do
            begin
              AddToHash(HTTP_data_out[locali], 0); // SHA - 1
              AddToHash(HTTP_data_out[locali], 1); // MD5
            end;
        
          Wait_With_Eth(500);
          if UDP_debug <> 0 then
            begin
              out_broadcast_local(33335, host_response_len_ssl, host_response);
            end;
          
          // **  server response consists of three parts:
          //    1. Server hello
          //    2. Server certificate
          //    3. Server hello done
          
          // 1. Server hello
            begin
              locali := 0;
              sessionIDLength := 0;
              serverCertificateLength := 0;
              certificateLength := 0;
              Mem_Set(@ServerRandom, 0, 32);

              if       (host_response[0] = 0x16) // this is a TLS response
                   and (host_response[1] = 0x03) // TLS 1.1
                   and (host_response[2] = 0x02) // TLS 1.1
                   and (host_response[5] = 0x02) // server hello
                 then begin
                   result := 2; // server hello expected
                   Hi(serverResponseLength) := host_response[3];
                   Lo(serverResponseLength) := host_response[4];
                   startIndex := 5; // exclude headers in hashing
                   stopIndex  := startIndex + serverResponseLength - 1;
                   for locali := startIndex to stopIndex do
                     begin
                       ClrWDT();
                       // hash the entire message, without headers
                       AddToHash(host_response[locali], 0); // SHA-1
                       AddToHash(host_response[locali], 1); // MD5
                       
                       // extract server random
                       if (locali >= 11) and (locali <= 42) then // server Random
                         begin
                           ServerRandom[locali - 11] := host_response[locali];
                           
                           if locali = 42 then
                             begin
                               debugMsg := 'Server Random';
                               out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);
                               out_broadcast_local(33335, 32, serverRandom);
                             end;
                         end;
  
                       // extract session id
                       if locali = 43 then
                         sessionIDLength := host_response[locali];
                         
                       if     (locali >= 44)
                          and (locali <= 44 + sessionIDLength - 1)
                          and (sessionIDLength <= 32)  then
                         begin
                           sessionID[locali - 44] := host_response[locali];
                         end;
                         
                       // extract ciphercuite value
                        // take two bytes of server's ciphesuite value
                       if (locali =  44 + sessionIDLength) then
                         serverCipherSuite[0] := host_response[locali];
                       if (locali =  44 + sessionIDLength + 1) then
                         serverCipherSuite[1] := host_response[locali];
                       
                       // server compression method
                       if (locali =  44 + sessionIDLength + 2) then
                          serverCompressionMethod := host_response[locali];
                          
                       // 7 bytes follow up, <length:2><extensions:5>
                       // todo: skiping server extensions
                       
                       // server certificate starts
                       if locali = 44 + 7 + sessionIDLength then
                         begin
                             serverCertificateStartIndex := locali;
                         end;
                     end;
                   
                   result := 0;
                 end;
            end;
          
          
          // 2. Server certificate
          if result = 0 then // proceed
            begin
              result := 3; // server certificate expected
              
              ServerCertificate.PublicKey.Key.Exponent[0] := 0;
              ServerCertificate.PublicKey.Key.Exponent[1] := 0;
              ServerCertificate.PublicKey.Key.Exponent[2] := 0;
              ServerCertificate.PublicKey.Key.Exponent[3] := 0;
              ServerCertificate.PublicKey.Key.BaseLength  := 0;
              ServerCertificate.PublicKey.Key.ExponentLength := 0;
              for locali := 0 to 511 do
                ServerCertificate.PublicKey.Key.Base[locali] := 0;

              locali := serverCertificateStartIndex;
              
              if (host_response[locali] = TLS_CERTIFICATE) then // server certificate 0x0b
                begin
                  Higher(serverCertificateLength) := host_response[locali + 1];
                  Hi(serverCertificateLength) := host_response[locali + 2];
                  Lo(serverCertificateLength) := host_response[locali + 3];

                  // extract certificates
                  startIndex := locali;
                  stopIndex  := startIndex + serverCertificateLength - 1;
                  X509Init(host_response, serverCertificateLength);
                  while startIndex < serverCertificateLength do
                    begin
                      DecodeCertificate(host_response, ServerCertificate, startIndex);
                      if ServerCertificate.PublicKey.Key.BaseLength > 0 then // we have the key
                        if ServerCertificate.PublicKey.Key.ExponentLength > 0 then // we have the key
                          break;
                    end;
                  result := 0;
                end;
            end;
            
         // 3. Server hello done
          if result = 0 then // proceed
            begin
              result := 4; // server hello done expected
              locali := stopIndex + 1;
              //the last four bytes should be 0E 00 00 00

              if      (host_response[host_response_len_ssl - 4] = 0x0e) // server hello done
                  and (host_response[host_response_len_ssl - 3] = 0x00)
                  and (host_response[host_response_len_ssl - 2] = 0x00)
                  and (host_response[host_response_len_ssl - 1] = 0x00)
                then begin
                  startIndex := locali;
                  stopIndex  := host_response_len_ssl - 1;
                  for locali := startIndex to stopIndex do
                     begin
                       // hash the entire message, without headers
                       AddToHash(host_response[locali], 0); // SHA-1
                       AddToHash(host_response[locali], 1); // MD5
                     end;
                  result := 0;
                end;
            end;
            
          Mem_Cpy(@certificate_output,@host_response,host_response_len_ssl);
          certificate_len := host_response_len_ssl;  
          // finish hashing
          MD5SHAFinal( @toHashMD5.dataIn,  @MD5Hash,  toHashMD5.dataLength,  0, 2);
          MD5SHAFinal( @toHashSHA1.dataIn, @SHA1Hash, toHashSHA1.dataLength, 1, 1);
          
          // prepare Client Key Exchange message
          messageLength := CreateClientKeyExchange();
          if SendTCP_SSL(messageLength) <> 0 then // we expect no response from the server
            begin
              Wait_With_Eth(500);
              //if UDP_debug <> 0 then
                begin
                  out_broadcast_local(33335, host_response_len_ssl, host_response);
                end;

              host_response_len_ssl := 0;
              messageLength := CreateChangeCipher();
              if SendTCP_SSL(messageLength) <> 0 then // we expect no response from the server
                begin
                  Wait_With_Eth(500);
                  //if UDP_debug <> 0 then
                    begin
                      debugMsg := 'Change Cipher Sent';
                      out_broadcast_local(33335, Str_Len(debugMsg), debugMsg);

                    end;
                    
                  messageLength := CreateClientFinished();
                  if SendTCPwait_SSL(messageLength) <> 0 then
                    begin
                      Wait_With_Eth(500);
                      //if UDP_debug <> 0 then
                        begin
                          out_broadcast_local(33335, host_response_len_ssl, host_response);
                        end;
                    end
                  else
                    begin
                      result := 7; // client Finished not sent
                      out_broadcast_local(33335, host_response_len_ssl, host_response);
                    end;
                end
              else
                begin
                  result := 6; // client ChangeCipher not sent
                end;
            end
          else
            begin
              result := 5; // clientkey exchange not sent
            end;
        end;


    end;
end;

// labelLength must be even and does not include a trailing zero, if any
// secretKeyLength must be even
procedure PRF(secretKey: ^byte; secretKeyLength: word;
              aLabel: ^byte; labelLength: word;
              seed: ^byte; seedLength: word;
              prfOut: ^byte; prfLength: word);
var s1, s2: array[64] of byte;
    i, L_S: byte;
    aMD5, hMD5: array[16] of char;
    aSHA1, hSHA1: array[20] of char;
    labelAndSeed1: array[64] of byte;
    labelAndSeed2: array[84] of byte;
    p: ^byte;
begin
  L_S := secretKeyLength div 2; // secretKeyLength must be even
  for i := 0 to L_S - 1 do
    begin
      s1[i] := secretKey^;
      inc(secretKey);
    end;
  for i := L_S to secretKeyLength - 1 do
    begin
      s2[i - L_S] := secretKey^;
      inc(secretKey);
    end;
  for i := 0 to labelLength - 1 do
    begin
      labelAndSeed1[i + 16] := aLabel^;
      labelAndSeed2[i + 20] := aLabel^;
      inc(aLabel);
    end;
  for i := 0 to seedLength - 1 do
    begin
      labelAndSeed1[labelLength + i + 16] := seed^;
      labelAndSeed2[labelLength + i + 20] := seed^;
      inc(seed);
    end;
  //A0
  p := @labelAndSeed1;
  p := p + 16;
  HMAC_MD5SHA(@s1, L_S, p, labelLength + seedLength,  aMD5, 1);
  //A1
  for i := 0 to 15 do
    begin
      labelAndSeed1[i] := aMD5[i];
    end;
  p := @labelAndSeed1;
  HMAC_MD5SHA(@s1, L_S, p, labelLength + seedLength + 16,  hMD5, 1);

  p := @labelAndSeed2;
  p := p + 20;
  HMAC_MD5SHA(@s2, L_S, p, labelLength + seedLength, aSHA1, 0);
  for i := 0 to 19 do
    begin
      labelAndSeed2[i] := aSHA1[i];
    end;
  
  p := @labelAndSeed2;
  HMAC_MD5SHA(@s2, L_S, p, labelLength + seedLength + 20,  hSHA1, 0);
  for i := 0 to prfLength - 1 do
    begin
      prfOut^ := hMD5[i] xor hSHA1[i];
      inc(prfOut);
    end;
end;



end.